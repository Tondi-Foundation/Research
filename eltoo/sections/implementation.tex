\section{Implementation Architecture}

\subsection{System Architecture Overview}

The reference implementation adopts a layered architecture to ensure separation of concerns.

\begin{table}[htbp]
\centering
\caption{Layered Architecture Components}
\label{tab:architecture}
\small
\begin{tabularx}{\linewidth}{@{}l l X@{}}
\toprule
\textbf{Layer} & \textbf{Responsibility} & \textbf{Key Components} \\
\midrule
Consensus & Validation Rules & \code{EltooBlockValidator} \\
UTXO & State Materialization & \code{RefOpUTXO}, \code{StateUTXO} \\
Protocol & State Machine & \code{ChannelStateMachine} \\
Application & User Interface & Wallet, RPC API \\
\bottomrule
\end{tabularx}
\end{table}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.8, transform shape,
    font=\sffamily\scriptsize,
    utxo/.style={rectangle, draw=gray, thick, rounded corners, minimum width=1.8cm, minimum height=1cm, fill=white},
    tx/.style={rectangle, draw=blue!80, thick, fill=blue!5, minimum width=2.2cm, minimum height=1.2cm},
    arrow/.style={->, >=Stealth, thick}
]
    % Inputs
    \node[utxo, fill=yellow!10] (fund) at (0, 3) {Fund UTXO};
    \node[below=0.05cm of fund, font=\tiny] {$V, \mathrm{AggVK}$};
    \node[utxo, fill=green!10] (state) at (0, 0) {State UTXO};
    \node[below=0.05cm of state, font=\tiny] {Seq $n$};
    \node[above=0.3cm of fund, font=\bfseries] {Inputs};

    % Transactions
    \node[tx] (update) at (4, 3) {Update Tx};
    \node[below=0.05cm of update, font=\tiny] {$\RefOp + \Spend$};
    \node[tx] (settle) at (4, 1) {Settle Tx};
    \node[tx] (splice) at (4, -1) {Splice Tx};
    \node[above=0.3cm of update, font=\bfseries] {Operations};

    % Outputs
    \node[utxo, fill=green!10] (newstate) at (8, 3) {New State};
    \node[below=0.05cm of newstate, font=\tiny] {Seq $n+1$};
    \node[utxo, fill=gray!10] (regular) at (8, 1) {Regular UTXOs};
    \node[utxo, fill=orange!10] (newfund) at (8, -1) {New Topology};
    \node[above=0.3cm of newstate, font=\bfseries] {Outputs};

    % Routing
    \draw[arrow, dashed, blue] (fund.east) -- node[above, font=\tiny] {Ref} (update.west);
    \draw[arrow] (state.east) -- ++(0.5,0) |- (update.west);
    \draw[arrow] (update.east) -- (newstate.west);

    \draw[arrow, dashed, blue] (fund.east) -- ++(0.3,0) |- (settle.west);
    \draw[arrow] (state.east) -- ++(0.3,0) |- (settle.west);
    \draw[arrow] (settle.east) -- (regular.west);

    \draw[arrow] (fund.east) -- ++(0.15,0) |- (splice.west);
    \draw[arrow] (state.east) -- ++(0.15,0) |- (splice.west);
    \draw[arrow] (splice.east) -- (newfund.west);

\end{tikzpicture}
\caption{Transaction Topology Flow. Dashed lines indicate non-consuming references ($\RefOp$), solid lines indicate value consumption ($\Spend$).}
\label{fig:tx_topology}
\end{figure}

\subsection{Consensus Layer Implementation}

\subsubsection{Transaction Type Enumeration}
The consensus layer uses algebraic data types to classify transactions:

\begin{lstlisting}[caption={Rust Enum for Transaction Types}, float=!htb]
enum EltooTxType {
    FUND { participants: Vec<PublicKey>, cap: u64 },
    UPDATE { ref_fund: OutPoint, seq: u64 },
    SETTLE { ref_fund: OutPoint, final_state: StateCommit },
    SPLICE { inputs: Vec<OutPoint>, outs: Vec<TxOut> },
}
\end{lstlisting}

\subsubsection{Validation Pipeline}
The \code{EltooBlockValidator} enforces state monotonicity (Theorem~\ref{thm:isolation}) and reference existence:

\begin{lstlisting}[caption={Monotonicity Validation Logic}, float=!htb]
fn validate_update(tx: &UpdateTx) -> Result<()> {
    let prev = get_state_utxo(tx.input_state)?;
    ensure!(tx.new_seq > prev.seq, "NonMonotonic");
    verify_ref_fund_exists(tx.ref_fund)?;
    Ok(())
}
\end{lstlisting}

\subsection{State Machine \& UTXO Indexing}

\subsubsection{State Transition}
The state machine handles local state evolution:

\begin{lstlisting}[caption={State Transition Implementation}, float=!htb]
impl ChannelStateMachine {
    fn apply(&mut self, event: Event) -> Result<()> {
        match event {
            Event::Update { balances, ptlcs } => {
                self.seq += 1;
                self.balances = balances;
                self.ptlcs = ptlcs;
            },
            Event::Settle => {
                self.state = State::Settling;
                self.timeout = now() + CSV_DELAY;
            },
            Event::Splice { topo } => {
                self.execute_splice(topo)?;
            }
        }
        Ok(())
    }
}
\end{lstlisting}

\subsubsection{Incremental Indexing}
To support registry-free discovery, we implement a lightweight indexer:

\begin{lstlisting}[caption={UTXO Indexer Structure}, float=!htb]
struct EltooIndexer {
    // Fast O(1) lookups
    utxo_index: HashMap<OutPoint, EltooUTXO>,
    // Channel lifecycle tracking
    channel_index: HashMap<ChannelID, ChannelUTXOs>,
    // Bloom filter for rapid ownership checks
    filter: BloomFilter,
}
\end{lstlisting}

\subsection{Cryptographic Primitives}

\subsubsection{MuSig2 Aggregation}

\begin{lstlisting}[caption={MuSig2 Signature Aggregation}, float=!htb]
fn aggregate_signatures(
    ctx: &MuSig2Context,
    partial_sigs: Vec<PartialSig>
) -> Signature {
    // Phase 1: Nonce Aggregation R = sum(R_i)
    let R: Point = ctx.nonces.iter().sum();
    // Phase 2: Sig Aggregation s = sum(s_i)
    let s: Scalar = partial_sigs.iter().map(|p| p.s).sum();
    Signature { R, s }
}
\end{lstlisting}

\subsection{Partially Signed Transaction Template (PSTT)}

For multi-party coordination, we define the PSTT standard.

\subsubsection{Domain Separation}
To prevent cross-protocol replay attacks, signatures are bound to specific domains:
$$ \sigma = \operatorname{Sign}_{sk}(\text{BLAKE3}(T_{\mathrm{dom}} \parallel m)) $$
where $T_{\mathrm{dom}} \in \{T_{\mathrm{FUND}}, T_{\mathrm{UPDATE}}, T_{\mathrm{SETTLE}}, T_{\mathrm{SPLICE}}\}$ are unique 8-byte domain separator tags.

\begin{theorem}[Cross-Protocol Security]
For types $A \neq B$, signature spaces are orthogonal:
$$ \forall m: \operatorname{Verify}(\operatorname{Sign}^A(m), m)_B = \mathtt{FALSE} $$
\end{theorem}

\subsubsection{PSTT Envelope}

\begin{lstlisting}[caption={PSTT Envelope Structure}, float=!htb]
pub struct PSTT {
    pub policy: PolicyFlags,
    pub payload: Option<EltooTxPayload>,
    pub partial_sigs: Vec<PartialSignature>,
    pub final_sig: Option<SchnorrSignature>,
}

impl PSTT {
    pub fn verify_domain(&self) -> Result<()> {
        let expected = self.payload.tx_type.domain_tag();
        for sig in &self.partial_sigs {
            if sig.tag != expected { return Err(DomainMismatch); }
        }
        Ok(())
    }
}
\end{lstlisting}

\begin{table}[htbp]
\centering
\caption{Communication Complexity}
\label{tab:impl-complexity}
\small
\begin{tabularx}{\linewidth}{@{}l X l@{}}
\toprule
\textbf{Protocol} & \textbf{Bandwidth} & \textbf{Rounds} \\
\midrule
Legacy Factory & $\mathcal{O}(N^2 \cdot |\sigma|)$ & $\mathcal{O}(N^2)$ \\
\textbf{PSTT + MuSig2} & $\mathcal{O}(N \cdot |\sigma|)$ & $\mathcal{O}(N)$ \\
\bottomrule
\end{tabularx}
\end{table}

Here $N$ denotes the number of channel participants, and $|\sigma|$ the signature size (64 bytes for Schnorr).

\subsection{Implementation Statistics}

The core implementation is written in Rust, prioritizing correctness.

\begin{table}[htbp]
\centering
\caption{Codebase Statistics (Rust)}
\label{tab:loc}
\small
\begin{tabular}{@{}l r@{}}
\toprule
\textbf{Component} & \textbf{LOC (approx.)} \\
\midrule
Consensus Validator & 2,000 \\
State Machine & 1,500 \\
UTXO Indexer & 1,200 \\
Crypto Primitives & 800 \\
Network Protocol & 1,000 \\
\textbf{Total Core} & \textbf{7,000} \\
\bottomrule
\end{tabular}
\end{table}
