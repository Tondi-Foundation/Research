\section{Topological Primitives for Complex Structures}

\subsection{Recursive Channel Factories}

Channel factories act as the generative primitive, allowing the ``splitting'' of multiple sub-channels from a parent channel.

\begin{definition}[Channel Factory]
A channel $C_{\mathrm{parent}}$ can generate a set of sub-channels $\{C_{\mathrm{child}_i}\}$ via a $\tau_{\mathrm{splice}}$ transaction. Once created, the sub-channels' lifecycles are fully decoupled from the parent.
\end{definition}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    font=\sffamily\scriptsize,
    % Increase spacing for better readability
    level 1/.style={sibling distance=3.5cm, level distance=1.5cm},
    level 2/.style={sibling distance=1.8cm, level distance=1.5cm},
    channel/.style={rectangle, draw, rounded corners, minimum width=1.4cm, minimum height=0.7cm, fill=blue!10, drop shadow, align=center},
    edge from parent/.style={draw, ->, >=Stealth, thick}
]
    % --- Tree Structure ---
    \node[channel, fill=orange!20] {Root}
        child {node[channel] {C1}
            child {node[channel, fill=green!10] {GC1}}
            child {node[channel, fill=green!10] {GC2}}
        }
        child {node[channel] {C2}
            child {node[channel, fill=green!10] {GC3}}
        };
        
    % --- Caption text (auto-positioned via bounding box) ---
    \node[below=0.4cm, font=\tiny\itshape, text=gray!80!black, anchor=north] 
        at (current bounding box.south) 
        {* Invariant at Depth $d$: $\sum \mathrm{Cap}_i = \mathrm{Cap}_{\mathrm{root}}$};

\end{tikzpicture}
\caption{Recursive Channel Factory Structure. The architecture supports arbitrary nesting depths while preserving total liquidity conservation.}
\label{fig:recursive-factory}
\end{figure}

\subsubsection{Fractal Topology and Self-Similarity}
The architecture manifests as a \textbf{self-similar $k$-ary tree}.
\begin{definition}[Split Operator]
Define mapping $\PhiOp: \mathcal{C} \to \{\mathcal{C}_1, \dots, \mathcal{C}_k\}$. For any recursion depth $d$, total channel capacity is conserved:
$$ \CapOp(C_{\text{root}}) = \sum_{i \in \text{Leaves}(d)} \CapOp(C_i) $$
This \textbf{scale invariance} property ensures the protocol logic remains identical regardless of tree depth.
\end{definition}

\begin{theorem}[Liquidity Conservation]
For any depth $d$, total capacity is conserved:
$$ \sum_{i \in \Nodes(d)} \CapOp(C_i) = \CapOp(C_{\mathrm{root}}) $$
\end{theorem}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.85,
    node distance=1.2cm,
    treenode/.style={draw, rounded corners, align=center, font=\scriptsize\sffamily, minimum width=1.4cm, minimum height=0.8cm, drop shadow, fill=white},
    root/.style={treenode, fill=red!10},
    child/.style={treenode, fill=green!10},
    grandchild/.style={treenode, fill=blue!10},
    depthlabel/.style={font=\tiny\bfseries, text=gray, anchor=west},
    >=Stealth
]
    % Root
    \node[root] (root) at (4,4) {Factory 1000};
    \node[depthlabel] at (8.5, 4) {Depth 0};
    
    % Depth 1
    \node[child] (c1) at (1.5,2) {Child$_1$ 400};
    \node[child] (c2) at (6.5,2) {Child$_2$ 600};
    \node[depthlabel] at (8.5, 2) {Depth 1};
    
    % Depth 2
    \node[grandchild] (g1) at (0,0) {GC$_1$ 150};
    \node[grandchild] (g2) at (3,0) {GC$_2$ 250};
    \node[grandchild] (g3) at (5,0) {GC$_3$ 300};
    \node[grandchild] (g4) at (8,0) {GC$_4$ 300};
    \node[depthlabel] at (9.2, 0) {Depth 2};
    
    % Edges
    \draw[->, thick] (root) -- node[left, font=\tiny] {$\PhiOp$} (c1);
    \draw[->, thick] (root) -- node[right, font=\tiny] {$\PhiOp$} (c2);
    \draw[->, thick] (c1) -- node[left, font=\tiny] {$\PhiOp$} (g1);
    \draw[->, thick] (c1) -- node[right, font=\tiny] {$\PhiOp$} (g2);
    \draw[->, thick] (c2) -- node[left, font=\tiny] {$\PhiOp$} (g3);
    \draw[->, thick] (c2) -- node[right, font=\tiny] {$\PhiOp$} (g4);
    
    % Auxiliary dashed lines for depth levels
    \draw[dashed, gray!30] (-0.5, 3) -- (9.5, 3);
    \draw[dashed, gray!30] (-0.5, 1) -- (9.5, 1);

\end{tikzpicture}
\caption{Fractal Channel Tree. Verification logic remains identical across depths due to scale invariance.}
\label{fig:fractal_tree}
\end{figure}

\subsection{Dynamic Mesh Reconfiguration}

\begin{theorem}[Atomic Reconfiguration]
Any topologically isomorphic channel networks can be atomically transformed via a single $\tau_{\mathrm{splice}}$ transaction.
\end{theorem}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.8, transform shape,
    node distance=1.2cm,
    font=\sffamily\scriptsize,
    party/.style={circle, draw, inner sep=2pt, fill=blue!10},
    conn/.style={thick}
]
    % Before
    \begin{scope}[local bounding box=ring]
        \node[party] (a) at (0,1.5) {A};
        \node[party] (b) at (1.5,1.5) {B};
        \node[party] (c) at (1.5,0) {C};
        \node[party] (d) at (0,0) {D};
        \draw[conn] (a)--(b)--(c)--(d)--(a);
        \node[above=0.2cm of ring] {Before: Ring};
    \end{scope}

    % Transition
    \draw[->, >=Stealth, double, thick] (2.5, 0.75) -- node[above] {$\tau_{\mathrm{splice}}$} (4.5, 0.75);

    % After
    \begin{scope}[xshift=5.5cm, local bounding box=star]
        \node[party, fill=orange!20] (h) at (0.75,0.75) {H};
        \node[party] (a2) at (0,1.5) {A};
        \node[party] (b2) at (1.5,1.5) {B};
        \node[party] (c2) at (1.5,0) {C};
        \node[party] (d2) at (0,0) {D};
        \foreach \p in {a2,b2,c2,d2} \draw[conn] (h)--(\p);
        \node[above=0.2cm of star] {After: Star};
    \end{scope}
\end{tikzpicture}
\caption{Atomic Topology Reconfiguration.}
\label{fig:topology-reconfig}
\end{figure}

\subsubsection{Topological Homotopy}
We view reconfiguration as a \textbf{homotopic transformation} $\mathcal{H}$:
$$ \mathcal{H}: G_1 \simeq G_2 \iff \exists \tau \in \Sigma_{\mathrm{splice}}: \delta(G_1, \tau) = G_2 $$
subject to $\sum_{e \in E_1} w(e) = \sum_{e \in E_2} w(e)$. This ensures no liquidity vacuum occurs.

\subsection{Atomic Rebalancing Operator}

\begin{invariant}[Strong Value Conservation]
\label{inv:conservation}
$$ V(U_{\mathrm{fund}}^{\mathrm{parent}}) + \sum V_{\mathrm{in}} = V(U_{\mathrm{fund}}^{\mathrm{parent}'}) + \sum V_{\mathrm{out}} + \delta_{\mathrm{fee}} $$
where $\delta_{\mathrm{fee}} \geq 0$ represents the transaction fee paid to miners.
\end{invariant}

\begin{algorithm}[t]
\caption{Deterministic Sub-channel ID Derivation}
\label{alg:id_derivation}
\begin{algorithmic}[1]
\Require Parent ID $\mathrm{ID}_p$, Fork OutPoint $\mathrm{OP}$, Index $j$, Participants $K$
\Ensure Unique Sub-channel ID
\State $D \gets \text{b"Eltoo\_V2\_SubChannel"}$ \Comment{Domain Separator}
\State $R \gets \text{MerkleRoot}(K)$
\State $\mathrm{ID}_{\mathrm{child}} \gets \text{BLAKE3}(D \parallel \mathrm{ID}_p \parallel \mathrm{OP} \parallel j \parallel R)$
\State \Return $\mathrm{ID}_{\mathrm{child}}$
\end{algorithmic}
\end{algorithm}

\subsection{Atomic Splicing Protocol}

This section defines the \textbf{Non-blocking Splicing Protocol}, addressing the ``stop-the-world'' problem in traditional channel maintenance.

\begin{table}[htbp]
\centering
\caption{Non-blocking Splicing Protocol Phases}
\label{tab:protocol}
\small
\begin{tabular}{@{}lp{6cm}@{}}
\toprule
\textbf{Phase} & \textbf{Operation Details} \\
\midrule
1. Proposal & Alice constructs $\tau_{\mathrm{splice}}$ and broadcasts to map $\OmegaOp$. Timeout $T_{\mathrm{ack}} = 30\text{s}$. \\
2. Async Sign & Participants generate partial signatures. \textbf{Channel remains active} for updates ($U_{\mathrm{state}}^{(n)}$). \\
3. Convergence & $\tau_{\mathrm{splice}}$ is broadcast. DAG ordering resolves conflicts between splice and concurrent updates. \\
4. Migration & New $U_{\mathrm{state}}^{(0)'}$ inherits old state's Merkle roots atomically. \\
\bottomrule
\end{tabular}
\end{table}

\begin{theorem}[Non-blocking Guarantee]
During protocol execution, channel liquidity remains available.
\end{theorem}
\begin{proof}
Phase 2 does not consume UTXOs. If $\tau_{\mathrm{update}}$ confirms before $\tau_{\mathrm{splice}}$, the splice input is invalidated (Rollback). If $\tau_{\mathrm{splice}}$ confirms first, updates target a spent UTXO (Reject). No invalid intermediate state exists.
\end{proof}

\subsection{Liquidity Dynamics in Star Topologies}

Define liquidity utilization $U(t)$ for a star graph:
$$ U(t) = \frac{\sum |\FlowOp_i(t)|}{\sum \CapOp_i} $$

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.8,
    hub/.style={circle, draw, fill=orange!30, font=\scriptsize},
    leaf/.style={circle, draw, fill=blue!10, inner sep=1pt, font=\tiny},
    edge label/.style={font=\tiny, midway, sloped, above}
]
    % Left
    \node[hub] (h1) {Hub};
    \foreach \ang/\name/\cap in {90/L1/10, 210/L2/90, 330/L3/5} {
        \node[leaf] (\name) at (\ang:1.5) {\name};
        \draw[->, red] (h1) -- node[edge label] {\cap/100} (\name);
    }
    \node[below=1.6cm of h1, font=\bfseries\tiny] {Fragmented};

    % Arrow
    \draw[->, thick, gray] (2.5, 0) -- node[above, font=\tiny] {Atomic Rebalance} (4.5, 0);

    % Right
    \begin{scope}[xshift=7cm]
        \node[hub] (h2) {Hub};
        \foreach \ang/\name/\cap in {90/L1/35, 210/L2/35, 330/L3/35} {
            \node[leaf] (\name2) at (\ang:1.5) {\name};
            \draw[->, blue!80!black] (h2) -- node[edge label] {\cap/100} (\name2);
        }
        \node[below=1.6cm of h2, font=\bfseries\tiny] {Optimal};
    \end{scope}
\end{tikzpicture}
\caption{Atomic Rebalance. Minimizing liquidity fragmentation via $\tau_{\mathrm{rebalance}}$.}
\label{fig:liquidity}
\end{figure}

\begin{theorem}[Balanced Flow Optimal Allocation]
For flow distribution $\vec{f}$, there exists strategy $\mathcal{R}$ minimizing fragmentation:
$$ \min_{\mathcal{R}} \sum (\CapOp'_i - f_i)^2 \quad \text{s.t. } \sum \CapOp'_i = \sum \CapOp_i $$
\end{theorem}
\begin{theorem}[Throughput Lower Bound]
Let $F_{\mathrm{rebalance}}$ denote the rebalancing frequency (transactions per unit time) and $\alpha \in (0,1]$ the channel utilization factor. The L1 throughput required to support atomic rebalancing is bounded by:
$$ \mathrm{TPS}_{L1} \geq \frac{F_{\mathrm{rebalance}}}{\mathrm{BlockSize}} \times \alpha $$
For typical parameters ($F = 100$ tx/s, BlockSize $= 10^6$ bytes, $\alpha = 0.7$), this yields $\mathrm{TPS}_{L1} \geq 0.07$, which is trivially satisfied by modern blockchains.
\end{theorem}
