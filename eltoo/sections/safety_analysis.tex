\section{Safety Analysis}
\label{sec:safety}

\subsection{Isolation Theorem}

\begin{theorem}[Channel Isolation]
\label{thm:isolation}
Sub-channel $C_{\mathrm{child}}$ security is independent of parent channel $C_{\mathrm{parent}}$ liveness or malicious behavior.
\end{theorem}

\begin{proof}
Isolation is guaranteed through four layers:
(1) \textbf{Physical}: $U_{\mathrm{fund}}^{\mathrm{child}}$ exists as an independent UTXO on L1.
(2) \textbf{Logical}: $C_{\mathrm{child}}$'s update transactions only refer to $\RefOp(U_{\mathrm{fund}}^{\mathrm{child}})$, decoupled from parent logic.
(3) \textbf{Settlement}: Even if the parent channel is maliciously settled, the sub-channel remains secure once its creation transaction is confirmed.
(4) \textbf{Temporal}: Independent CSV timers use DAA Scores, avoiding block height dependencies.
\end{proof}

\subsection{State Monotonicity and Anti-Replay}

\begin{theorem}[Cross-Topology Anti-Replay]
\label{thm:anti_replay}
Any channel's old state cannot be replayed after topology reconfiguration.
\end{theorem}

\begin{proof}[Proof Sketch]
The anti-replay property relies on the binding of signatures to specific UTXO outpoints.
$$ \sigma = \operatorname{Sign}_{sk}(\state{n} \parallel \text{RefOp\_Outpoint}) $$
Since $\tau_{\mathrm{splice}}$ creates a new $U_{\mathrm{fund}}'$, the \texttt{RefOp\_Outpoint} changes. Additionally, key derivation is isolated via $AggVK_{\mathrm{child}} = H(AggVK_{\mathrm{parent}} \parallel \text{index})$. Thus, $\forall \sigma_{\mathrm{old}}$, no valid replay exists in $C_{\mathrm{new}}$.
\end{proof}

\subsection{Anti-DoS Equilibrium under STPC Strategy}

Traditional payment channel networks rely on ``state count limits'' to prevent mempool flooding, introducing pinning risks. This architecture implements the \textbf{Single-Tip-Per-Channel (STPC)} strategy.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    font=\sffamily\scriptsize,
    box/.style={rectangle, draw, rounded corners, minimum height=0.7cm, align=center},
    arrow/.style={->, >=Stealth, thick}
]
    % Mempool Container
    \node[rectangle, draw, dashed, minimum width=3.5cm, minimum height=2.5cm, fill=gray!5, label={[anchor=north]north:Mempool}] (pool) {};
    
    % Current Tip
    \node[box, fill=green!20, minimum width=2cm] (tip) at (pool.center) {State$_n$\\(Unique Tip)};
    
    % Incoming
    \node[box, fill=blue!10, left=3cm of pool.north west, anchor=north] (valid1) {State$_{n+1}$};
    \node[box, fill=orange!10, below=0.3cm of valid1] (valid2) {State$_n$\\High Fee};
    \node[box, fill=red!10, below=0.3cm of valid2] (invalid) {State$_{n-1}$};
    
    % Logic
    \draw[arrow, green!60!black] (valid1.east) -- node[above, sloped, font=\tiny] {Replace} (tip.west);
    \draw[arrow, orange!60!black] (valid2.east) -- node[above, sloped, font=\tiny] {RBSS} (tip.west);
    \draw[arrow, red] (invalid.east) -- node[below, font=\tiny] {Reject} (pool.west |- invalid);
    
\end{tikzpicture}
\caption{STPC (Single-Tip-Per-Channel) Strategy. Limits mempool DoS exposure.}
\label{fig:stpc}
\end{figure}

\subsubsection{Mempool Entropy Bound}
STPC acts as an \textbf{entropy-reducing filter}. In open networks, attackers attempt to maximize mempool disorder. STPC constrains the maximum entropy $S_{\max}$:
\begin{equation}
S_{\max} = k_B \cdot \ln(N_{\mathrm{channels}})
\end{equation}
where $k_B$ is a protocol-defined constant (analogous to Boltzmann's constant in thermodynamics) representing the base entropy per channel slot. Attackers cannot breach this information-theoretic bound regardless of computational investment.

\begin{table}[htbp]
\centering
\caption{Mempool Entropy and DoS Analysis}
\label{tab:entropy}
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Model} & \textbf{Entropy} & \textbf{DoS Bound} & \textbf{State Limit} \\
\midrule
Traditional LN & Unbounded & Unbounded & None \\
\textbf{Proposed STPC} & $\bigO(\ln N)$ & $\le N_{\mathrm{channels}}$ & Strict \\
\bottomrule
\end{tabular}
\end{table}

\begin{definition}[STPC Replacement Rules]
Let $\calM$ be the mempool, $\tau_{tip} \in \calM$ be the current highest state transaction for a channel. For new transaction $\tau_{new}$:
\begin{enumerate}
    \item \textbf{Rule I (Monotonic Replacement)}: If $\state{new} > \state{tip}$, unconditionally replace $\tau_{tip}$
    \item \textbf{Rule II (RBSS)}: If $\state{new} = \state{tip}$, only replace when $\mathrm{FeeRate}(\tau_{new}) \ge \mathrm{FeeRate}(\tau_{tip}) + \Delta_{min}$
    \item \textbf{Rule III (Rejection)}: If $\state{new} < \state{tip}$, directly reject
\end{enumerate}
\end{definition}

\begin{theorem}[DoS Cost Escalation]
\label{thm:dos}
STPC escalates the effective cost of DoS attacks from $\bigO(1)$ to $\bigO(N)$, where $N$ is the total number of state updates the attacker must produce. The cumulative attack cost is:
$$ \cost{DoS} = \sum_{i=1}^{k} \cost{tx}(\tau_i) \in \Omega(k) $$
where $k$ is the number of malicious update attempts.
\end{theorem}

Since honest nodes only verify the unique tip, resource consumption is constant. To maintain an attack, the adversary must monotonically increase state commitments ($\state{k} > \state{k-1} > \dots > \state{1}$), eventually exhausting the pre-signed state space.

\subsection{PTLC Atomicity and Deadlock Freedom}

\subsubsection{PTLC Atomicity Theorem}
\begin{theorem}[PTLC Atomicity]
\label{thm:ptlc}
For path $P = c_1 \to \dots \to c_n$, fund transfer implies global consistency:
$$ \forall i \in [1, n-1]: \operatorname{Settle}(c_i) \iff \operatorname{Settle}(c_{i+1}) $$
\end{theorem}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=2.2cm,
    font=\sffamily\scriptsize,
    party/.style={circle, draw, fill=gray!10, minimum size=0.9cm},
    arrow/.style={->, >=Stealth, thick}
]
    \node[party] (A) {Alice};
    \node[party, right=of A] (B) {Bob};
    \node[party, right=of B] (C) {Carol};
    
    % Forward
    \draw[arrow, blue] (A) -- node[above] {PTLC($Q$)} (B);
    \draw[arrow, blue] (B) -- node[above] {PTLC($Q$)} (C);
    
    % Backward
    \draw[arrow, red, dashed, bend left=40] (C) to node[below] {Reveal $s$} (B);
    \draw[arrow, red, dashed, bend left=40] (B) to node[below] {Reveal $s$} (A);
    
    \node[below=0.8cm of B, font=\tiny, align=center] {Atomicity: $Q = s \cdot G$\\$s$ unlocks all hops simultaneously};
\end{tikzpicture}
\caption{PTLC Multi-Hop Atomic Payment.}
\label{fig:ptlc-payment}
\end{figure}

\begin{proof}
Based on Adaptor Signatures: once the recipient reveals the preimage (scalar $s$) at $c_n$, $s$ becomes the decryption key for $c_{n-1}$. This propagates recursively to $c_1$. Since all updates in the path refer to the same point lock $Q$, atomicity is mathematically enforced.
\end{proof}

\subsubsection{Deadlock Freedom}
\begin{theorem}[Deadlock Freedom]
\label{thm:deadlock}
No circular dependencies (deadlocks) exist under GhostDAG ordering.
\end{theorem}
\begin{proof}
Assume a cycle exists in the dependency graph: $t_1 < t_2 < \dots < t_n < t_1$. Since each PTLC timeout is expressed as an absolute DAA Score, and DAA Scores form a globally monotonic sequence across the DAG, any valid ordering must satisfy $t_1 < t_2 < \dots < t_n$. The assumption $t_n < t_1$ contradicts $t_1 < t_n$ (by transitivity). Thus, no such cycle exists, and the system is deadlock-free.
\end{proof}

\subsection{Consistency of Topological Reconfiguration}

\begin{theorem}[Splicing Consistency]
\label{thm:splice}
Concurrent \code{SPLICE-FORK} operations guarantee:
(1) \textbf{Value Conservation}: $\sum V_{\mathrm{in}} = \sum V_{\mathrm{out}}$.
(2) \textbf{Unique History}: GhostDAG converges to a single valid topology.
\end{theorem}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=0.8cm,
    font=\sffamily\scriptsize,
    box/.style={rectangle, draw, minimum width=1.8cm, minimum height=0.8cm, align=center, rounded corners},
    state/.style={box, fill=blue!10},
    splice/.style={box, fill=orange!10},
    final/.style={box, fill=green!10}
]
    \node[state] (curr) {Current State UTXO};
    
    \node[splice, below left=1cm and 0.2cm of curr] (s1) {Splice A ($W_A$)};
    \node[splice, below right=1cm and 0.2cm of curr] (s2) {Splice B ($W_B$)};
    
    \draw[->, thick] (curr) -| (s1);
    \draw[->, thick] (curr) -| (s2);
    
    % Decision
    \node[diamond, draw, aspect=2.5, below=1.5cm of curr, fill=gray!5, font=\tiny, inner sep=1pt] (dag) {$W_A > W_B$?};
    
    \draw[->, dashed] (s1) -- (dag);
    \draw[->, dashed] (s2) -- (dag);
    
    \node[final, below=0.8cm of dag] (res) {Final Topology A};
    \node[right=0.5cm of res, text=red] (rej) {B Discarded};
    
    \draw[->, thick] (dag) -- node[right, font=\tiny] {Confirm} (res);
    \draw[->, thick, red, dashed] (s2) -- (rej);
    
\end{tikzpicture}
\caption{Conflict resolution for concurrent Splicing via GhostDAG weight.}
\label{fig:splice_conflict}
\end{figure}

\begin{proof}
While $\RefOp$ allows concurrent reads, splicing requires \textbf{spending} the State UTXO. Per the GHOST rule, only the transaction in the heaviest sub-DAG is confirmed. Conflicting spends are discarded, ensuring linear consistency.
\end{proof}

\subsection{Security Margin Analysis}

Table~\ref{tab:security_margin} summarizes the architectural improvements.

\begin{table}[htbp]
\centering
\caption{Security Margin Comparison}
\label{tab:security_margin}
\small
\begin{tabular}{@{}lp{5.5cm}@{}}
\toprule
\textbf{Dimension} & \textbf{Improvement Mechanism} \\
\midrule
State Theft & Monotonic replacement eliminates penalty txs \\
Replay & Domain separation + UTXO binding \\
DoS & STPC forces $\cost{Attack} \propto \bigO(N)$ \\
Offline & DAA timelocks support week-level tolerance \\
Recovery & Toxic-waste free; only latest state needed \\
\bottomrule
\end{tabular}
\end{table}

This model aligns with the principle: \textit{centralize complexity at the protocol layer, leaving simplicity for the application layer}.
