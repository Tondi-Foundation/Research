\documentclass[11pt,a4paper]{article}

% ============ Packages ============
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools} % Enhanced math typesetting
\DeclareMathOperator{\Enc}{Enc}
\DeclareMathOperator{\Dec}{Dec}
\DeclareMathOperator{\Link}{Link}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tabularx} % Auto-width tables
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{shapes,shapes.geometric,arrows,arrows.meta,positioning,calc,fit,backgrounds,shadows}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage{forest}

\geometry{margin=1in}

% ============ Theorem Environments ============
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{axiom}{Axiom}
\newtheorem{invariant}{Invariant}[section]
\newtheorem{protocol}{Protocol}[section]

% ============ Code Listings (IEEE Style for Rust) ============
\definecolor{rustKeyword}{RGB}{204, 120, 50}
\definecolor{rustType}{RGB}{86, 156, 214}
\definecolor{rustComment}{RGB}{106, 153, 85}
\definecolor{rustString}{RGB}{206, 145, 120}
\definecolor{rustMacro}{RGB}{220, 220, 170}
\definecolor{rustLifetime}{RGB}{86, 156, 214}

\lstdefinelanguage{Rust}{
    keywords={fn, let, mut, pub, struct, enum, impl, self, Self, match, if, else, while, for, loop, return, break, continue, use, mod, crate, super, type, where, trait, as, const, static, ref, move, async, await, dyn, unsafe, extern},
    keywordstyle=\bfseries\color{rustKeyword},
    morekeywords=[2]{u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, f32, f64, bool, char, str, String, Vec, HashMap, Option, Result, Ok, Err, Some, None, Box, Rc, Arc, PublicKey, OutPoint, DAAScore, AggregateKey, StateCommitment, Output, Transaction, PTLC, Event, State},
    keywordstyle=[2]\color{rustType},
    morekeywords=[3]{ensure, derive},
    keywordstyle=[3]\color{rustMacro},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\itshape\color{rustComment},
    morestring=[b]",
    stringstyle=\color{rustString},
}

% TLA+ Language Definition
\lstdefinelanguage{TLA}{
    morekeywords={MODULE, VARIABLES, CONSTANTS, EXTENDS, INSTANCE, THEOREM, ASSUME, VARIABLE, CONSTANT},
    keywordstyle=\bfseries\color{purple!80!black},
    morecomment=[s]{(*}{*)},
    commentstyle=\itshape\color{gray},
    basicstyle=\ttfamily\scriptsize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b,
    showstringspaces=false,
    escapeinside={(*@}{@*)}
}

\lstset{
    language=Rust,
    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\bfseries\color{rustKeyword},
    commentstyle=\itshape\color{rustComment},
    stringstyle=\color{rustString},
    showstringspaces=false,
    breaklines=true,
    breakatwhitespace=true,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{gray!50},
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=5pt,
    stepnumber=1,
    tabsize=4,
    captionpos=b,
    aboveskip=8pt,
    belowskip=4pt,
    xleftmargin=12pt,
    framexleftmargin=10pt,
    columns=flexible,
    keepspaces=true,
    escapeinside={(*@}{@*)},
}

% ============ Custom Commands ============
\newcommand{\calU}{\mathcal{U}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\RefOp}{\operatorname{Ref}}
\newcommand{\Spend}{\operatorname{Spend}}
\newcommand{\bigO}{\mathcal{O}} % Big-O notation
\newcommand{\state}[1]{\mathsf{State}_{#1}} % Semantic state symbol
\newcommand{\cost}[1]{\mathrm{Cost}_{\mathrm{#1}}} % Semantic cost symbol
\newcommand{\code}[1]{\texttt{#1}} % Inline code
\newcommand{\rfc}[1]{\textsc{#1}} % RFC 2119 keywords (MUST, SHOULD, etc.)

% Economic/Incentive Notation
\newcommand{\Rcsp}{R_{\mathrm{CSP}}}
\newcommand{\Ulp}{U_{\mathrm{LP}}}
\newcommand{\Cmarg}{C_{\mathrm{marg}}}
\newcommand{\CLone}{C_{\mathrm{L1}}}
\newcommand{\Fee}{\mathrm{Fee}}

% Topological Operators
\newcommand{\PhiOp}{\Phi} % Split operator
\newcommand{\OmegaOp}{\Omega} % Rebalance operator
\newcommand{\CapOp}{\mathrm{Cap}}
\newcommand{\FlowOp}{\mathrm{Flow}}
\newcommand{\Nodes}{\mathrm{Nodes}}

% ============ Document Info ============
\title{Generalized Payment Channel Topologies via Dual-Track State Machines and Reference-Based UTXOs}

\author{
    \\[1em]
    Arthur Zhang\thanks{Corresponding author: Arthur Zhang (arthur@tondi.org)} \\
    \textit{Tondi Foundation} \\[1.5em]
    Neo Maxwell \\
    \textit{Tondi Foundation} \\[0.5em]
    Yunli Zhu \\
    \textit{DI Foundation}
}

\date{December, 2025}

\begin{document}

\maketitle


\vspace{1em}

% ============ Abstract ============
\begin{abstract}
Payment Channel Networks (PCN) constitute a Layer 2 scaling solution for blockchain systems, whose core principle is to complete multiple state updates off-chain while settling only the final state on-chain, thereby improving system throughput.

\textbf{Background and Problem Definition:} Existing PCN schemes (such as the Lightning Network) exhibit two categories of structural limitations: (1) the expressiveness of the Script Layer is constrained, making it difficult to natively support complex state transition semantics; (2) linear topology structures lead to low capital utilization and excessive state management complexity. While the original Eltoo protocol proposed a state replacement mechanism to supersede the penalty mode, its implementation depends on the not-yet-activated \texttt{SIGHASH\_ANYPREVOUT} soft fork (BIP-118) and presents security concerns such as replay attacks.

\textbf{Technical Contributions:} This paper proposes a general-purpose scaling architecture based on native Eltoo semantics. The main contributions include:
\begin{enumerate}
    \item \textbf{Dual-Track UTXO Model:} Decomposing channel state into a static fund anchor (Fund UTXO) and a dynamic state pointer (State UTXO) along two orthogonal dimensions, achieving separation of concerns between value transfer and state transitions;
    \item \textbf{Reference-Based UTXO Primitive:} Defining a read-only reference operator $\RefOp: \calU \to \calU^{readonly}$, enabling state update transactions to access fund anchor metadata without consuming that UTXO;
    \item \textbf{Transaction Type Enumeration System:} Embedding algebraic data types at the consensus layer to achieve $\bigO(1)$ complexity for transaction classification and verification;
    \item \textbf{Recursive Channel Factories and Atomic Reconfiguration:} Formally defining channel splitting (Splice-Fork) and merging (Splice-Merge) operations, proving that any complex topology can achieve isomorphic transformation through a single atomic transaction.
\end{enumerate}

\textbf{Theoretical Results:} This paper proves the existence of a bijective mapping between UTXO sets and channel state sets (Theorem 8), thereby eliminating dependency on off-chain registries. Under DAG-structured consensus protocols, state verification complexity is $\bigO(1)$, with settlement latency reaching sub-second levels.

\textbf{Keywords:} Payment Channel Networks, State Channels, Eltoo Protocol, UTXO Model, Finite State Machine, Formal Verification, Layer 2 Scaling
\end{abstract}

\newpage
\tableofcontents
\newpage

% ============ Section 0: Introduction ============
\section{Introduction and Motivation}

\subsection{Problem Background}

The core design objective of payment channel networks is to transfer transaction processing from on-chain to off-chain while maintaining security guarantees. Achieving this objective faces the following fundamental challenges:

\begin{enumerate}
    \item \textbf{State Consistency Problem:} How to ensure consistency between off-chain state and on-chain settlement? Off-chain states evolve rapidly, but only the final state should be enforceable on-chain.
    
    \item \textbf{Trust Model Problem:} How to resolve disputes without third-party arbitration? Traditional approaches rely on game-theoretic punishment mechanisms, but these introduce new vulnerabilities.
    
    \item \textbf{Storage Overhead Problem (Toxic Waste):} Penalty-based mechanisms require permanent storage of all historical revocation keys. Any data loss exposes honest parties to fund theft, creating an unbounded storage liability that grows linearly with channel lifetime.
    
    \item \textbf{Protocol Dependency Problem:} Existing state replacement solutions (e.g., original Eltoo) require consensus-layer changes such as \texttt{SIGHASH\_ANYPREVOUT} (BIP-118), creating deployment barriers and cross-chain incompatibility.
    
    \item \textbf{Liveness and Availability Problem:} Payment channels demand continuous monitoring to detect and respond to malicious state broadcasts. Watchtower delegation introduces additional trust assumptions and operational costs.
    
    \item \textbf{Verification Complexity Problem:} Script-based channel protocols push substantial verification logic into on-chain execution, increasing transaction weight, fee costs, and potential attack surfaces from script interpreter vulnerabilities.
    
    \item \textbf{Base Layer Throughput and Finality Problem:} Bitcoin's approximately 10-minute block interval and probabilistic finality create fundamental tension with payment channel requirements. Channel operations (opening, closing, dispute resolution) compete for scarce block space, while the lack of deterministic finality introduces uncertainty in settlement guarantees. These constraints are not incidental but intrinsic to Bitcoin's security model.
\end{enumerate}

\subsection{The Layer Inversion Insight}

The enumerated problems share a common root cause: \textbf{attempting to retrofit Layer 2 semantics onto a Layer 1 designed without consideration for off-chain protocols}. Bitcoin's architecture optimizes for a specific set of properties---censorship resistance, minimal trust assumptions, and simplicity---but these design choices create friction when supporting payment channel networks.

This observation leads to a philosophical reframing:

\begin{quote}
\textit{Rather than adapting payment channels to fit an existing base layer, we should ask: what would a base layer look like if it were designed from inception to natively support state channel topologies?}
\end{quote}

This paper pursues this question to its logical conclusion. We propose an architecture that inverts the traditional layering relationship: instead of treating L2 as an afterthought bolted onto L1, we design L1 and L2 as a \textbf{co-optimized system} where:
\begin{itemize}
    \item The consensus layer provides native primitives for state channel operations (not script-level simulation)
    \item The UTXO model is extended with reference semantics specifically for dual-track state representation
    \item A GhostDAG-based consensus enables high-throughput, low-cost on-chain state checkpointing
\end{itemize}

The choice of GhostDAG consensus is not incidental but architecturally motivated. DAG-structured block production permits concurrent block creation, yielding sub-second block intervals and massive throughput increases over linear chains. This transforms the economics of on-chain interaction: channel participants can affordably record state checkpoints on-chain, creating cryptographic evidence that bounds the window of vulnerability to stale-state attacks.

Crucially, while DAG consensus introduces the possibility of deeper reorganizations compared to single-chain protocols, the security properties \textit{converge faster in wall-clock time}. Under equivalent elapsed time, a GhostDAG chain accumulates more confirming blocks than Bitcoin, and the cost of mounting a reorganization attack scales with the \textit{number of concurrent blocks} an adversary must produce---not merely hash power. After a modest number of confirmations, state checkpoint UTXOs achieve settlement guarantees that match or exceed Bitcoin's, while providing orders-of-magnitude faster initial confirmation.

This is not merely an engineering optimization but a \textbf{paradigm shift}: from ``How do we build channels on Bitcoin?'' to ``How do we build a base layer for channels?'' The resulting architecture eliminates entire categories of problems rather than mitigating them.

\subsection{Design Principles}

The dual-track state machine architecture proposed in this paper operationalizes the layer inversion insight through the following design principles:

\textbf{Principle 1: Consensus-Layer Native Semantics}
Embed channel operation semantics within consensus rules rather than simulating through the script layer. This provides two advantages:
\begin{itemize}
    \item Verification complexity reduces from $\bigO(\text{script\_size})$ to $\bigO(1)$
    \item Eliminates uncertainty introduced by script interpreters
\end{itemize}

\textbf{Principle 2: Orthogonal Separation of Value and State}
Decompose channel representation into two independent dimensions:
\begin{itemize}
    \item \textbf{Value Layer (Fund UTXO):} Carries fund locking, with stable lifecycle
    \item \textbf{State Layer (State UTXO):} Carries state evolution, with high-frequency updates
\end{itemize}

This separation ensures that state updates need not touch the fund locking structure, reducing verification complexity.

\textbf{Principle 3: Non-Punitive State Replacement}
Replace penalty-based revocation with monotonic state supersession. Any party can publish a newer state to override an older one, eliminating the need for:
\begin{itemize}
    \item Permanent storage of revocation secrets (toxic waste elimination)
    \item Complex punishment transaction graphs
    \item Asymmetric information advantages between channel participants
\end{itemize}

\textbf{Principle 4: Deterministic State Execution}
Traditional contract execution relies on ex post enforcement (through arbitration), introducing cost and time uncertainty. The proposed architecture achieves ex ante enforcement through consensus rules:
\begin{align*}
\text{Traditional Mode: } & \text{Contract} \xrightarrow{\text{Dispute}} \text{Arbitration} \xrightarrow{\text{Judgment}} \text{Enforcement} \\
\text{The proposed architecture: } & \text{State\_UTXO} \xrightarrow{\tau_{\text{settle}}} \text{Value\_Distribution} \quad (\text{deterministic execution})
\end{align*}

\textbf{Principle 5: Minimal External Dependency}
The protocol operates without requiring:
\begin{itemize}
    \item External registries or naming services for channel discovery
    \item Continuous watchtower availability (degraded to optional optimization)
    \item Specific soft-fork upgrades (e.g., \texttt{SIGHASH\_ANYPREVOUT})
\end{itemize}

Fund UTXO serves as the sole cryptographic anchor, making channel existence self-evident from on-chain state.

\subsection{Trust Model Analysis}

Blockchain system security is often described as ``trust minimization.'' The proposed architecture further pursues \textbf{trust elimination}---making certain types of trust assumptions unnecessary through protocol design:

\begin{table}[htbp]
\centering
\small
\caption{Trust Model Comparison}
\begin{tabular}{@{}p{4cm}p{2.5cm}p{2.8cm}p{3.5cm}@{}}
\toprule
\textbf{Trust Assumption} & \textbf{Traditional PCN} & \textbf{The proposed architecture} & \textbf{Elimination Mechanism} \\
\midrule
Channel registry availability & Required & Not required & Fund UTXO as sole anchor \\
Watchtower continuous online & Strong dependency & Weak dependency & Long-period timelocks + state replacement \\
Script interpreter correctness & Required & Not required & Consensus-layer native types \\
\bottomrule
\end{tabular}
\end{table}

The core insight of The proposed architecture is: by pushing complexity down to the protocol layer, a simpler trust model can be achieved at the application layer.

% ============ Section 1: Related Work ============
\newpage
\input{sections/related_work}

% ============ Section 2: Research Contributions ============
\newpage
\input{sections/contributions}

% ============ Section 3: Theoretical Framework ============
\newpage
\input{sections/theoretical_framework}

% ============ Section 4: Topological Primitives ============
\newpage
\input{sections/topological_primitives}

% ============ Section 5: Safety Analysis ============
\newpage
\input{sections/safety_analysis}

% ============ Section 6: Registry-Free Architecture ============
\newpage
\input{sections/registry_free}

% ============ Section 7: Implementation Architecture ============
\newpage
\input{sections/implementation}

% ============ Section 8: Attack Surface Analysis ============
\newpage
\input{sections/attack_analysis}

% ============ Section 9: Application Scenarios ============
\newpage
\input{sections/applications}

% ============ Section 10: Evaluation and Performance ============
\newpage
\input{sections/evaluation}

% ============ Section 11: Privacy and Anonymity ============
\newpage
\input{sections/privacy}

% ============ Section 12: Market Design and Incentives ============
\newpage
\input{sections/incentives}

% ============ Section 13: Conclusion ============
\newpage
\input{sections/conclusion}

% ============ Appendix: Glossary ============
\newpage
\input{sections/appendix}

% ============ References ============
\newpage
\begin{thebibliography}{99}

\bibitem{nakamoto2008bitcoin}
S. Nakamoto, ``Bitcoin: A Peer-to-Peer Electronic Cash System,'' 2008.

\bibitem{poon2016lightning}
J. Poon and T. Dryja, ``The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments,'' 2016.

\bibitem{decker2018eltoo}
C. Decker, R. Russell, and O. Osuntokun, ``eltoo: A Simple Layer2 Protocol for Bitcoin,'' 2018.

\bibitem{bip118}
C. Decker and A. J. Towns, ``BIP-118: SIGHASH\_ANYPREVOUT for off-chain protocols,'' Bitcoin Improvement Proposal, 2019.

\bibitem{sompolinsky2015ghostdag}
Y. Sompolinsky and A. Zohar, ``Secure High-Rate Transaction Processing in Bitcoin,'' in Financial Cryptography and Data Security, 2015.

\bibitem{kaspa2021}
Y. Sompolinsky et al., ``Phantom and GhostDAG: A Scalable Generalization of Nakamoto Consensus,'' Cryptology ePrint Archive, 2021.

\bibitem{maxwell2018musig}
G. Maxwell, A. Poelstra, Y. Seurin, and P. Wuille, ``Simple Schnorr Multi-Signatures with Applications to Bitcoin,'' in IACR ePrint, 2018.

\bibitem{nick2021musig2}
J. Nick, T. Ruffing, and Y. Seurin, ``MuSig2: Simple Two-Round Schnorr Multi-Signatures,'' in CRYPTO, 2021.

\bibitem{poelstra2016mimblewimble}
A. Poelstra, ``Mimblewimble,'' 2016.

\bibitem{malavolta2019adaptor}
G. Malavolta, P. Moreno-Sanchez, C. Schneidewind, A. Kate, and M. Maffei, ``Anonymous Multi-Hop Locks for Blockchain Scalability and Interoperability,'' in NDSS, 2019.

\bibitem{aumayr2021bitcoin}
L. Aumayr et al., ``Generalized Bitcoin-Compatible Channels,'' Cryptology ePrint Archive, 2021.

\bibitem{miller2017sprites}
A. Miller, I. Bentov, S. Bakshi, R. Kumaresan, and P. McCorry, ``Sprites and State Channels: Payment Networks that Go Faster than Lightning,'' in Financial Cryptography, 2019.

\bibitem{dziembowski2019perun}
S. Dziembowski, L. Eckey, S. Faust, and D. Malinowski, ``Perun: Virtual Payment Hubs over Cryptocurrencies,'' in IEEE S\&P, 2019.

\bibitem{lamport1982tla}
L. Lamport, ``Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers,'' Addison-Wesley, 2002.

\bibitem{coquand1988coq}
T. Coquand and G. Huet, ``The Calculus of Constructions,'' Information and Computation, 1988.

\end{thebibliography}

\end{document}
