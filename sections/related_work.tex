\section{Related Work and Technical Background}

This section provides a comprehensive analysis of the evolution of payment channel protocols, identifies the structural defects inherent in existing solutions, and establishes the technical foundation for the proposed architecture. For formal definitions of cryptographic primitives and notation conventions, readers are referred to Appendix~\ref{appendix:glossary}.

\subsection{Protocol Evolution: From Penalty to Replacement}

Payment channel protocols have evolved through two distinct paradigms: \textbf{penalty-based revocation} and \textbf{state replacement}. Understanding the fundamental differences between these approaches---and why neither fully solves the problem---is essential for motivating the architectural innovations presented in this paper.

\subsubsection{Lightning Network's Penalty Mechanism}

The Lightning Network~\cite{poon2016lightning} pioneered the practical deployment of payment channels on Bitcoin. Its security model relies on a \textbf{penalty mechanism} to deter participants from broadcasting outdated channel states.

\textbf{Mechanism Overview.} Consider a channel between parties Alice and Bob with state sequence $S_0, S_1, \ldots, S_n$. When transitioning from state $S_n$ to $S_{n+1}$, both parties perform a key exchange: Alice reveals her ``revocation key'' for $S_n$ to Bob, and vice versa. This revocation key enables the counterparty to claim \textit{all} funds in the channel if an outdated state is broadcast.

\textbf{Formal Security Property.} Let $\mathcal{R}_i^A$ denote the revocation key that Alice holds for state $S_i$, which would allow her to punish Bob if he broadcasts $S_i$ after $S_{i+1}$ has been agreed upon. The security guarantee can be expressed as:
$$\forall i < n: \mathcal{R}_i^A \in \text{Alice's\_storage} \implies \text{Bob broadcasting } S_i \text{ results in total fund loss for Bob}$$

This creates a game-theoretic equilibrium: rational actors will never broadcast old states because the expected punishment exceeds any potential gain.

\textbf{Structural Defects (The ``Toxic Waste'' Problem).} Despite its elegance, the penalty mechanism introduces fundamental operational burdens:
\begin{enumerate}
    \item \textbf{Unbounded Storage Growth:} Each state update generates a new revocation key that must be stored permanently. For a channel with $n$ state transitions, nodes must maintain $\bigO(n)$ historical keys. Long-lived, high-frequency channels can accumulate millions of revocation secrets.
    
    \item \textbf{Catastrophic Failure Mode:} Data loss is not merely inconvenient---it is catastrophic. If Alice loses her revocation keys and inadvertently broadcasts an old state (e.g., from a corrupted backup), Bob can legitimately claim all funds. This transforms routine operational failures into complete fund loss.
    
    \item \textbf{Backup Complexity:} The requirement to never lose \textit{any} historical key while \textit{also} never using an old backup (which might trigger a penalty) creates a paradoxical backup strategy. Users must maintain perfectly synchronized, append-only storage with no tolerance for errors.
\end{enumerate}

The term ``toxic waste'' aptly describes this accumulation: revocation keys are useless during normal operation but potentially deadly if mishandled, and they can never be safely discarded.

\subsubsection{Eltoo Protocol and State Replacement}

The Eltoo protocol~\cite{decker2018eltoo} represents a fundamental paradigm shift from punishment to \textbf{state replacement}. Rather than penalizing old states, Eltoo allows newer states to simply supersede older ones through a clever use of transaction structure.

\textbf{Core Mechanism.} In Eltoo, each state $S_n$ corresponds to an ``update transaction'' $\tau_n$. The key innovation is that $\tau_{n+1}$ can validly spend the output of \textit{any} prior update transaction $\tau_i$ where $i \leq n$. This is achieved through a signature scheme that does not commit to the specific input being spent.

\textbf{State Supersession Semantics.} If a malicious party broadcasts an old state $\tau_i$, the honest party can respond by broadcasting $\tau_n$ (the latest state), which will:
\begin{enumerate}
    \item Spend the output of $\tau_i$ as its input
    \item Replace the outdated state with the current one
    \item Require no punishment---the old state is simply overwritten
\end{enumerate}

\textbf{Protocol Dependency on SIGHASH\_ANYPREVOUT.} The Eltoo mechanism requires signatures that bind to the \textit{script logic} of an input rather than its specific identity (the OutPoint, which consists of a transaction ID and output index). This is formalized in BIP-118~\cite{bip118} as the \code{SIGHASH\_ANYPREVOUT} flag. The signature hash is computed as:
$$ h_{\mathrm{APO}} = H(\tau.\text{outputs} \parallel \tau.\text{inputs}[i].\text{script} \parallel \tau.\text{version} \parallel \dots) $$

Notably, this hash \textit{omits} the OutPoint identifier of the input being spent. This allows a single pre-signed transaction to spend from any UTXO that matches the expected script, enabling the state replacement mechanism.

\textbf{Advantages over Penalty Mechanism:}
\begin{itemize}
    \item \textbf{Constant Storage:} Only the latest state needs to be stored; historical states can be safely discarded.
    \item \textbf{Symmetric Information:} Both parties hold identical transaction sets, eliminating information asymmetry.
    \item \textbf{Simpler Backup:} Restoring from an old backup does not risk fund loss---the counterparty simply publishes the newer state.
\end{itemize}

\subsubsection{Engineering Compromise of BIP-118}

While Eltoo's state replacement mechanism is theoretically elegant, its implementation via BIP-118 introduces significant engineering challenges and security concerns.

\textbf{The Replay Attack Vector.} The flexibility of \code{ANYPREVOUT} signatures creates a dangerous attack surface: if a signature is created for one UTXO, it can potentially be ``replayed'' against any other UTXO with a matching script. This means that careless key reuse across different channels---or even within the same channel after a splice operation---could allow an attacker to redirect funds.

\textbf{Mitigation via Public Key Tagging.} To address this, BIP-118 mandates a \textbf{physical segregation} of public keys used for ANYPREVOUT operations. The verification logic becomes:
$$
\texttt{Verify}_{\mathrm{APO}}(\sigma, m, P) =
\begin{cases}
\texttt{FALSE} & \text{if } P \in \mathcal{K}_{\mathrm{std}} \text{ (standard key space)} \\
\texttt{SchnorrVerify}(\sigma, m, P) & \text{if } P \in \mathcal{K}_{\mathrm{apo}} \text{ (APO-tagged key space)}
\end{cases}
$$

This means APO signatures are only valid when used with specially-tagged public keys that belong to a distinct derivation path. Standard keys cannot be used with APO, and vice versa.

\textbf{The Shifted Security Burden.} While this tagging scheme prevents \textit{accidental} cross-contamination, it fundamentally \textbf{shifts security responsibility from the protocol layer to the application layer}:
\begin{itemize}
    \item Wallet developers must implement correct key derivation paths
    \item Users must never reuse keys across different contexts
    \item A single implementation bug or user error can lead to complete fund loss
\end{itemize}

This violates the principle of defense in depth: the protocol should prevent dangerous operations, not merely trust applications to avoid them.

\subsection{The Recursive Covenant Dilemma}

Beyond its immediate security concerns, \code{SIGHASH\_ANYPREVOUT} introduces a more fundamental philosophical debate within the Bitcoin community regarding \textbf{recursive covenants}.

\textbf{What are Covenants?} A covenant is a spending condition that restricts not just \textit{who} can spend a UTXO, but \textit{how} it can be spent---specifically, what form the spending transaction's outputs must take. Traditional Bitcoin scripts answer the question ``who holds the key?'' Covenants answer the question ``what happens to the funds next?''

\textbf{The Recursion Problem.} ANYPREVOUT enables a form of transaction introspection: a script $S$ can effectively examine properties of the spending transaction. If $S$ can enforce that its output must be locked by a script $S'$ where $S' \equiv S$ (or a controlled variant), then funds can be \textbf{permanently constrained} to follow specific paths indefinitely.

Formally, let $\mathcal{C}(S)$ denote the set of valid spending patterns from script $S$:
$$\text{Recursive Covenant: } \exists S : \forall \tau \in \mathcal{C}(S), \tau.\text{outputs} \subseteq \{\text{UTXOs locked by } S\}$$

\textbf{Community Concerns.} This capability raises serious objections:
\begin{enumerate}
    \item \textbf{Fungibility Risk:} Coins could be ``tainted'' with permanent restrictions (e.g., regulatory whitelists), creating second-class bitcoins that are worth less than unrestricted coins.
    
    \item \textbf{Censorship Vectors:} Governments could mandate that exchanges only accept coins locked in compliant covenants, fragmenting the monetary supply.
    
    \item \textbf{Unintended Complexity:} Recursive covenants could enable Turing-complete computation on-chain, fundamentally changing Bitcoin's computational model.
\end{enumerate}

\textbf{Impact on Protocol Adoption.} These concerns have contributed to the prolonged stalling of BIP-118 activation. The Bitcoin community's conservative approach to consensus changes means that any feature with potential for ``toxic recursion'' faces significant resistance, regardless of its benefits for payment channels.

This political reality underscores the value of our proposed architecture: by achieving Eltoo semantics \textit{without} relying on ANYPREVOUT, we sidestep this entire debate.

\subsection{BIP-118 Security Boundary Analysis}

To concretize the security concerns discussed abstractly above, we analyze the specific attack surface created by BIP-118's design choices. Figure~\ref{fig:bip118} illustrates how security responsibility ``leaks'' from the consensus layer to the application layer.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=1.2cm and 0.5cm,
    font=\sffamily\scriptsize,
    box/.style={rectangle, draw, rounded corners, minimum height=0.7cm, minimum width=1.6cm, fill=white, align=center},
    danger/.style={box, fill=red!10, draw=red, text=red!80!black},
    layer_bg/.style={rectangle, draw=gray, dashed, inner sep=0.3cm, fill=gray!5, rounded corners},
    arrow/.style={->, >=Stealth, thick}
]

    % --- 1. Define Nodes First ---
    
    % Protocol Layer Nodes (Bottom)
    \node[box, fill=blue!10] (sig) {APO Signature};
    \node[box, right=1.5cm of sig] (valid) {Valid?};
    \node[right=0.8cm of valid] (output) {};

    % Application Layer Nodes (Top)
    \node[box, above=2.0cm of sig] (pk) {Public Key $P$};
    \node[box, left=1.0cm of pk] (deriv) {Derivation\\Path};
    \node[danger, right=1.0cm of pk] (misuse) {Key Reuse /\\Misuse};

    % --- 1.5 Define Spacers ---
    \coordinate (proto_spacer) at ($(sig.north) + (0, 0.4)$);
    \coordinate (app_spacer) at ($(pk.north) + (0, 0.4)$);

    % --- 2. Draw Background Layers ---
    \begin{scope}[on background layer]
        \node[layer_bg, fit=(sig) (valid) (output) (proto_spacer), 
              label={[anchor=north west, text=gray!90!black, font=\bfseries\tiny, inner sep=5pt]north west:Consensus Layer (Logic OK)}] (proto_layer) {};
        
        \node[layer_bg, fit=(pk) (deriv) (misuse) (app_spacer), 
              label={[anchor=north west, text=gray!90!black, font=\bfseries\tiny, inner sep=5pt]north west:User / Wallet Layer (Fragile)}] (app_layer) {};
    \end{scope}

    % --- 3. Connections ---
    \draw[arrow] (deriv) -- (pk);
    \draw[arrow, red, dashed] (pk) -- (misuse);
    \draw[arrow] (sig) -- (valid);
    \draw[arrow] (valid) -- node[above, font=\tiny] {Yes} (output);

    % Cross-Layer Attack Arrow
    \draw[arrow, red] (misuse.south) 
        -- ++(0, -0.6) 
        -| node[pos=0.25, right, font=\tiny, text=red, align=left] {Replay\\Attack} 
        ($(sig.north) + (0.5, 0)$);

    % --- 4. Gap Annotation ---
    \path (proto_layer.north) -- (app_layer.south) node[midway, fill=white, inner sep=3pt, font=\tiny\bfseries, text=gray!80!black] {Engineering Gap};

\end{tikzpicture}
\caption{BIP-118 Security Boundary Leakage. The consensus layer correctly verifies APO signatures, but security ultimately depends on correct key derivation paths implemented in wallets. Key reuse between standard and APO contexts enables replay attacks despite sound protocol logic. The ``Engineering Gap'' represents the trust assumption that applications will not make mistakes.}
\label{fig:bip118}
\end{figure}

\textbf{The Core Vulnerability.} The fundamental issue is \textbf{implicit state dependency}: the security of an ANYPREVOUT signature depends on context that is not visible to the signature verification algorithm. Specifically:
\begin{enumerate}
    \item A signature $\sigma$ is created for a particular channel state
    \item The signature is valid for \textit{any} UTXO with matching script
    \item If the same key pair is used elsewhere (different channel, post-splice, etc.), $\sigma$ can be ``replayed'' to steal funds
\end{enumerate}

The consensus layer cannot detect this attack because each individual signature verification succeeds. The attack exploits the \textit{relationship} between multiple valid operations, which is invisible at the transaction level.

\textbf{Contrast with Proposed Architecture.} Our approach eliminates this vulnerability through type-level isolation:
\begin{itemize}
    \item Each channel's Fund UTXO has a unique identifier embedded in the State UTXO
    \item The $\RefOp$ operator cryptographically binds state updates to specific fund anchors
    \item Replay is impossible because the reference check would fail for any UTXO other than the intended target
\end{itemize}

This represents a fundamental design principle: \textbf{security invariants should be enforced by the protocol, not assumed of applications}.

\subsection{Structural Defect Analysis}

Having examined the specific protocols, we now abstract to identify \textbf{structural defects} common to script-based payment channel implementations. These defects arise from a fundamental mismatch: attempting to simulate state machine semantics using a language (Bitcoin Script) designed for simple predicate evaluation.

\textbf{The Orthogonality Principle.} Well-designed systems maintain separation between independent concerns. In payment channels, two orthogonal concerns exist:
\begin{itemize}
    \item \textbf{Value Custody:} Which keys control the funds?
    \item \textbf{State Evolution:} What is the current balance distribution, and how does it change?
\end{itemize}

Script-based solutions \textbf{violate orthogonality} by encoding state logic directly into spending conditions, entangling these concerns.

\begin{table}[htbp]
\centering
\caption{Structural Defects of Script-Based Payment Channel Solutions}
\label{tab:defects}
\small
\begin{tabularx}{\linewidth}{@{}p{2.8cm}X@{}}
\toprule
\textbf{Defect Category} & \textbf{Technical Impact and Consequences} \\
\midrule
\textbf{Verification Complexity} & Transaction validation requires executing the full script, resulting in $\bigO(\textit{script\_size})$ computational cost. Script size is unbounded and unpredictable, making resource consumption difficult to estimate and enabling potential DoS vectors. \\
\addlinespace
\textbf{Semantic Opacity} & The consensus layer cannot distinguish between a channel state update and a regular fund transfer---both appear as script executions. This prevents the base layer from optimizing for channel operations or providing specialized guarantees. \\
\addlinespace
\textbf{Blurred Security Boundaries} & Security depends on application-layer behaviors (key management, derivation paths) rather than protocol-level invariants. The consensus layer provides mechanisms but not policies, shifting liability to wallet implementations. \\
\addlinespace
\textbf{Concern Coupling} & Value locking logic (multi-signatures) and state transition logic (sequence numbers, timelocks) are interleaved in the same script. Modifying one concern risks breaking the other. \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{The Root Cause.} These defects share a common origin: script-based solutions treat the blockchain as a \textit{general-purpose computation platform} and simulate channel semantics through clever encoding. Our architecture inverts this relationship: the blockchain natively understands channel operations, and verification becomes a matter of type checking rather than program execution.

\subsection{Comparison of Revocation Mechanisms}

Table~\ref{tab:comparison} provides a systematic comparison between the original Eltoo protocol (which depends on BIP-118) and the proposed architecture. For clarity, we refer to the proposed architecture as \textbf{Eltoo 2.0} throughout this paper, reflecting its role as a successor that achieves Eltoo's design goals through consensus-native mechanisms rather than script-level simulation.

\begin{table}[htbp]
\centering
\caption{State Revocation Mechanisms: Original Eltoo vs.\ Eltoo 2.0 (Proposed Architecture)}
\label{tab:comparison}
\small
\begin{tabularx}{\linewidth}{@{}p{2.2cm}XX@{}}
\toprule
\textbf{Feature} & \textbf{Original Eltoo (BIP-118)} & \textbf{Eltoo 2.0 (This Paper)} \\
\midrule
\textbf{Core Primitive} & Script-level overwrite using \code{SIGHASH\_NOINPUT} & Consensus-layer transaction types with dual-track UTXO model \\
\addlinespace
\textbf{Scalability Model} & Complex script logic limits factory size & Native channel factory support with $\bigO(1)$ verification \\
\addlinespace
\textbf{Data Requirements} & Full transaction parsing and script execution & Store only latest state; constant-size verification \\
\addlinespace
\textbf{Determinism} & Signature-dependent; requires pre-signing all possible paths & Virtual reference enables deterministic state lookup \\
\addlinespace
\textbf{DoS Resistance} & Weak; script execution is unbounded & Strong; State-Type-Protected Commitment (STPC) strategy \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{Key Architectural Differences:}
\begin{itemize}
    \item \textbf{Abstraction Level:} Original Eltoo operates at the script layer, encoding state machine logic in spending conditions. Eltoo 2.0 operates at the transaction type layer, where state transitions are first-class operations.
    
    \item \textbf{Security Model:} Original Eltoo's security depends on correct application-layer key management. Eltoo 2.0's security is enforced by consensus rules---applications cannot violate invariants even if buggy.
    
    \item \textbf{Deployment Path:} Original Eltoo requires a Bitcoin soft fork (BIP-118) with uncertain timeline. Eltoo 2.0 is designed for new chains built with native support, avoiding political obstacles.
\end{itemize}

\subsection{Proposed Solution: UTXO-Native Semantics}

The defects enumerated above motivate our core architectural decision: rather than simulating Eltoo semantics through script-level tricks, we propose \textbf{embedding these semantics directly into the UTXO model and transaction type system}.

\textbf{Design Philosophy.} The key insight is that payment channel operations are not arbitrary computations---they follow a small, well-defined set of patterns. By making these patterns \textit{first-class citizens} of the transaction model, we can:
\begin{enumerate}
    \item Verify operations through type checking rather than script execution
    \item Enforce invariants at the consensus layer rather than trusting applications
    \item Enable the base layer to optimize specifically for channel workloads
\end{enumerate}

\textbf{Transaction Type System.} We introduce a typed transaction model where each transaction declares its semantic intent:
\begin{itemize}
    \item \textbf{Type Enforcement:} For all transactions $\tau$ in the Eltoo transaction set $\mathcal{T}_{\mathrm{Eltoo}}$, the inputs \rfc{must} be of type \code{ELTOO\_STATE}. This is not a script-level check but a consensus-level type constraint.
    
    \item \textbf{Replay Isolation:} Because \code{ELTOO\_STATE} UTXOs can only be spent by Eltoo update transactions, and standard UTXOs cannot be inputs to such transactions, replay attacks are \textit{physically impossible} at the type level---no key management discipline required.
\end{itemize}

\textbf{FSM vs.\ Arbitrary Recursion.} The Eltoo state machine follows strict monotonicity: each update transaction carries a sequence number $n$, and valid transitions require $n' > n$. This constraint is enforced by consensus:
$$\forall \tau_{\text{update}}: \tau_{\text{update}}.\text{output\_seq} > \tau_{\text{update}}.\text{input\_seq}$$

This monotonicity property \textit{mathematically precludes} arbitrary recursive covenants. The state can only move forward, never loop or branch arbitrarily. We gain the benefits of state replacement without opening the door to Turing-complete on-chain computation.

\textbf{Explicit Reference Operator.} The $\RefOp$ primitive enables a transaction to \textit{read} a UTXO's metadata without consuming it:
$$\RefOp(U) \in \tau.\text{references} \implies U \in \mathcal{U}_{\text{post-}\tau}$$

This reduces verification complexity from $\bigO(\text{script\_size})$ to $\bigO(1)$: the verifier checks that the referenced UTXO exists and has the expected properties, rather than executing arbitrary code.

\subsection{Axiom System}

The proposed architecture is built upon a minimal set of axioms that capture the essential properties of sound payment channel operation. These axioms serve as the foundation for formal verification and guide implementation decisions.

\begin{table}[htbp]
\centering
\caption{Core Axiom System for Dual-Track State Channels}
\label{tab:axioms}
\small
\begin{tabularx}{\linewidth}{@{}p{1.0cm}X@{}}
\toprule
\textbf{Axiom} & \textbf{Formal Expression and Semantic Interpretation} \\
\midrule
\textbf{A1} & $\mathcal{S}_{\mathrm{channel}} \cong \mathcal{U}_{\mathrm{chain}}$ \newline
\textit{Isomorphism:} There exists a bijective mapping between the set of valid channel states and the set of on-chain UTXO configurations. Every channel state corresponds to exactly one UTXO pattern, and vice versa. This eliminates the need for off-chain registries. \\
\addlinespace
\textbf{A2} & $\forall \tau_{\mathrm{update}}: n' > n$ \newline
\textit{Strict Monotonicity:} Every state update transaction must carry a sequence number strictly greater than its input. This ensures unidirectional state evolution and prevents replay of old states. \\
\addlinespace
\textbf{A3} & $\RefOp(U) \in \tau \implies U \in \mathcal{U}_{\mathrm{post}}$ \newline
\textit{Non-Consumption:} When a transaction references a UTXO via the $\RefOp$ operator, that UTXO remains unspent after the transaction is processed. References provide read-only access without affecting ownership. \\
\addlinespace
\textbf{A4} & $\sum V_{\mathrm{in}} = \sum V_{\mathrm{out}} + \delta_{\mathrm{fee}}$ \newline
\textit{Value Conservation:} The sum of input values equals the sum of output values plus transaction fees. No value is created or destroyed during state transitions. \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{Axiom Interdependencies.} These axioms are not independent; they form a coherent system:
\begin{itemize}
    \item A1 (Isomorphism) depends on A3 (Non-Consumption): the ability to reference without consuming is what enables the dual-track structure that makes isomorphism possible.
    \item A2 (Monotonicity) enforces the finite state machine semantics that prevent recursive covenants.
    \item A4 (Conservation) is the standard UTXO invariant, extended to account for the reference mechanism.
\end{itemize}

\subsection{DAG Consensus Compatibility}

The proposed architecture is designed for deployment on GhostDAG-based consensus protocols~\cite{sompolinsky2015ghostdag, kaspa2021}. This choice is not incidental but architecturally motivated by the synergy between DAG properties and payment channel requirements.

\textbf{Why GhostDAG?} Traditional blockchain consensus produces a single chain of blocks, where concurrent blocks become ``orphans'' that are discarded. GhostDAG instead organizes blocks into a Directed Acyclic Graph, where concurrent blocks can \textit{all} contribute to consensus.

Given network parameters $(D, k)$ where $D$ is the maximum network delay bound and $k$ is the security parameter, GhostDAG provides:

\begin{enumerate}
    \item \textbf{Temporal Consistency via DAA Score:} The Difficulty Adjustment Algorithm (DAA) Score provides a globally monotonic logical clock. For any two blocks $b_1 \prec b_2$ in the DAG partial order:
    $$\text{DAA}(b_1) < \text{DAA}(b_2)$$
    This property enables precise relative timelocks for channel dispute periods without relying on wall-clock time.
    
    \item \textbf{Fast Confirmation:} Block confirmation time is determined by network propagation delay rather than artificial throttling. The expected confirmation latency is:
    $$E[\text{confirmation\_time}] = \Theta\left(\frac{D}{k}\right)$$
    For typical parameters ($D \approx 2$s, $k \approx 16$), this yields sub-second initial confirmation---orders of magnitude faster than Bitcoin's 10-minute blocks.
    
    \item \textbf{Throughput Scaling:} Because concurrent blocks are not wasted, effective throughput scales with the block production rate:
    $$\text{TPS}_{\text{effective}} \approx k \times \text{TPS}_{\text{single-chain}}$$
    This high throughput makes on-chain state checkpointing economically viable.
\end{enumerate}

\textbf{Implications for Payment Channels.} The combination of fast confirmation and high throughput fundamentally changes the design space for payment channels:
\begin{itemize}
    \item State checkpoints can be recorded on-chain affordably, reducing reliance on watchtowers
    \item Dispute periods can be shorter (in wall-clock time) while providing equivalent security
    \item Channel factories become more practical due to reduced coordination overhead
\end{itemize}

\subsection{Economic Efficiency Boundary}

Beyond security considerations, Layer 2 protocols must be evaluated on their \textbf{economic efficiency}---the ability to provide fast, cheap transactions without excessive capital lockup or operational overhead. We analyze protocols in a three-dimensional design space:
$$\Omega = \mathcal{L} \times \mathcal{T} \times \mathcal{C}$$

\textbf{Dimension Definitions}:
\begin{itemize}
    \item \textbf{Latency ($\mathcal{L}$):} Time from payment initiation to final settlement guarantee. Lower is better.
    \item \textbf{Throughput ($\mathcal{T}$):} Maximum transaction processing rate. Higher is better.
    \item \textbf{Capital Efficiency ($\mathcal{C}$):} Ratio of usable liquidity to locked capital. Higher means less ``dead'' capital.
\end{itemize}

\begin{table}[htbp]
\centering
\caption{Economic Positioning of Layer 2 Protocols in the $\Omega$ Design Space}
\label{tab:economics}
\small
\begin{tabularx}{\linewidth}{@{}p{2.2cm}XXX@{}}
\toprule
\textbf{Protocol Class} & \textbf{Latency} & \textbf{Capital Efficiency} & \textbf{Trust Model} \\
\midrule
\textbf{Bitcoin L1} & 10--60 minutes (probabilistic finality) & Baseline (no lockup) & Full decentralized consensus \\
\addlinespace
\textbf{Optimistic Rollups} & 1--15 minutes (challenge period) & Medium (operator collateral) & Operator honesty + L1 fallback \\
\addlinespace
\textbf{Lightning Network} & Sub-second (off-chain) & Low (bilateral lockup) & Watchtower availability \\
\addlinespace
\textbf{Native Eltoo (Proposed)} & Sub-second (off-chain) & High (pooled via factories) & Consensus-enforced invariants \\
\bottomrule
\end{tabularx}
\end{table}

\textbf{The Capital Efficiency Problem.} Traditional payment channels suffer from \textbf{bilateral capital fragmentation}: if Alice has channels with Bob and Carol, her capital is split between them. She cannot use her Bob-channel balance to pay Carol directly without routing, which incurs fees and may fail due to liquidity constraints.

Channel factories address this by \textbf{pooling capital} among multiple participants. However, on Bitcoin, factory operations are expensive due to high on-chain fees and slow confirmation. This limits practical factory sizes.

\textbf{Native Eltoo's Economic Advantage.} Our architecture enables larger, more dynamic channel factories through:
\begin{enumerate}
    \item \textbf{Low-cost reconfiguration:} Factory membership changes require only $\bigO(1)$ on-chain operations, not $\bigO(n)$ bilateral channel updates.
    \item \textbf{Fast finality:} GhostDAG's sub-second confirmation enables rapid factory operations without long waiting periods.
    \item \textbf{Reduced time-value cost:} The economic cost of locked capital is $\gamma \cdot C \cdot t$, where $\gamma$ is the opportunity cost rate, $C$ is locked capital, and $t$ is lock duration. Faster operations reduce $t$, directly improving capital efficiency.
\end{enumerate}

For high-frequency payment flows (micropayments, streaming payments, gaming), these improvements compound: smaller latency enables tighter capital management, which reduces opportunity costs, which enables smaller margins, which attracts more volume.
