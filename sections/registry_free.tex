\section{Registry-Free Architecture}

\subsection{Limitations of Global Registries}

Traditional designs (e.g., Lightning) rely on centralized gossip protocols, introducing:
(1) \textbf{Privacy Leakage} via public graph announcements;
(2) \textbf{Scalability Bottlenecks} from $\bigO(N^2)$ gossip message complexity (each of $N$ nodes broadcasts to all others);
(3) \textbf{Censorship Risks} at registry entry points.

\subsection{Self-Sovereign Channel Discovery}

We implement a \textbf{registry-free} mechanism where channels are discovered solely by parsing the UTXO set.
\begin{definition}[Self-Sovereign Discovery]
$$ \text{Discover}(C) \equiv \Phi_{\mathrm{filter}}(\text{UTXO\_Set}) \to \{U_{\mathrm{fund}}, U_{\mathrm{state}}\} $$
\end{definition}

\begin{theorem}[Discovery Completeness]
For any channel $C$ involving node $N$, on-chain scanning is sufficient for state reconstruction.
\end{theorem}
\begin{proof}
Since $(U_{\mathrm{fund}}, U_{\mathrm{state}})$ are deterministic and immutable on L1, and $N$ holds the keys to verify ownership, the on-chain data provides a complete, source-of-truth restoration without off-chain dependency.
\end{proof}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.85, transform shape,
    font=\sffamily\scriptsize,
    utxo/.style={rectangle, draw=gray, fill=gray!10, minimum width=1.8cm, minimum height=0.6cm, inner sep=2pt},
    valid/.style={rectangle, draw=blue!80!black, fill=blue!10, minimum width=1.8cm, minimum height=0.6cm, inner sep=2pt, thick},
    channel/.style={rectangle, draw=green!60!black, fill=green!10, minimum width=2.2cm, minimum height=1cm, rounded corners},
    lens/.style={trapezium, trapezium angle=70, draw=purple, thick, fill=purple!5, minimum width=2.5cm, minimum height=4cm, shape border rotate=270, align=center}
]

    % L1: Raw UTXO Set (Left)
    \node[anchor=south west, font=\bfseries\small] at (-0.5, 4.2) {L1: Raw UTXO Set};
    \node[utxo] (u1) at (0, 3.5) {Standard P2TR};
    \node[valid] (u2) at (0, 2.5) {Eltoo Fund A};
    \node[utxo] (u3) at (0, 1.5) {Standard P2WPKH};
    \node[valid] (u4) at (0, 0.5) {Eltoo State A};
    
    % The Lens (Middle)
    \node[lens] (filter) at (4, 2) {$\Phi$ Type Filter};
    \node[below=0.1cm of filter, font=\tiny] {(Pattern Matching)};
    
    % Arrows into Lens
    \draw[->, gray, dashed] (u1.east) -- (filter.west |- u1.east);
    \draw[->, blue, thick] (u2.east) -- (filter.west |- u2.east);
    \draw[->, gray, dashed] (u3.east) -- (filter.west |- u3.east);
    \draw[->, blue, thick] (u4.east) -- (filter.west |- u4.east);
    
    % L2: Constructed View (Right)
    \node[anchor=south west, font=\bfseries\small] at (6.5, 4.2) {L2: Channel View};
    \node[channel] (c1) at (7.5, 1.5) {Channel A (State $n=50$)};
    
    % Beams out of Lens
    \fill[blue!20, opacity=0.3] (filter.east |- u2.east) -- (c1.north west) -- (c1.south west) -- (filter.east |- u4.east) -- cycle;
    \draw[->, blue, thick] (filter.east |- u2.east) -- node[above, font=\tiny, sloped] {Reconstruct} (c1.west);
    
    % Annotation
    \node[below=0.5cm of filter, align=center, font=\tiny, text=purple] {Complexity $\bigO(N)$\\Single Pass Scan};

\end{tikzpicture}
\caption{UTXO-to-State Projection. The discovery function $\Phi$ acts as a lens, filtering raw blockchain data into a logical channel view without external registries.}
\label{fig:utxo_projection}
\end{figure}

\subsection{Privacy Enhancement}
\subsubsection{Ephemeral Identity}
Channel ID changes with every splice:
$$ ID_C^{(i)} = H(\text{domain} \parallel \text{RefOp\_Outpoint}_i \parallel \text{salt}) $$
where $\text{salt}$ is a deterministically derived value from the splice transaction (e.g., the transaction ID or a counter). This guarantees \textbf{temporal unlinkability} and \textbf{graph analysis resistance}.

\subsection{Comparison with Centralized Models}

\begin{table}[htbp]
\centering
\caption{Registry Model Comparison}
\label{tab:registry_comparison}
\small
\begin{tabularx}{\linewidth}{@{}lXX@{}}
\toprule
\textbf{Dimension} & \textbf{Lightning (Gossip)} & \textbf{Proposed (Registry-Free)} \\
\midrule
Discovery & P2P Gossip Flood & On-chain Scan ($\Phi$) \\
Privacy & Public Broadcast & \textbf{Self-Sovereign} \\
Scalability & $\bigO(N^2)$ & $\bigO(N)$ (Linear) \\
Identity & Static & \textbf{Ephemeral} \\
Censorship & Weak & Strong (UTXO-based) \\
\bottomrule
\end{tabularx}
\end{table}

\subsection{Economic Incentive Alignment}

\begin{theorem}[Discovery Cost Bound]
Discovering $M$ owned channels from a UTXO set of size $N$:
$$ \mathrm{Cost}_{\mathrm{discovery}} = \bigO(N) + \bigO(M) $$
The first term represents the single-pass scan over all UTXOs; the second represents the cost of reconstructing $M$ channel states. Unlike gossip-based discovery which requires maintaining and synchronizing a global graph, this approach is purely local and on-demand.
\end{theorem}
This linear complexity enables practical client-side filtering, eliminating the ``free-rider'' problem of unpaid gossip announcements.

\subsection{PTLC Verification: $\bigO(1)$ Implementation}

By leveraging the $\RefOp$ mechanism, verification avoids script interpretation overhead.

\begin{lstlisting}[caption={Constant-Time PTLC Verification Logic}, label={lst:ptlc_verify}]
fn validate_ptlc(settle: &SettleTx, utxo_set: &UtxoSet) -> bool {
    // 1. O(1) Lookup via Reference Operator
    let fund_utxo = utxo_set.get_ref(settle.fund_ref);
    let keys = fund_utxo.metadata.participant_keys;
    
    // 2. Batch Verification of Curve Relationships
    // Verify: reveal_scalar * G == point_lock - beneficiary_key
    for ptlc in settle.ptlcs.iter() {
        let expected = ptlc.point_q - keys[ptlc.beneficiary_idx];
        if ptlc.reveal_scalar * GENERATOR != expected {
            return false;
        }
    }
    true
}
\end{lstlisting}

\begin{table}[htbp]
\centering
\caption{Verification Complexity Comparison}
\label{tab:complexity}
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Metric} & \textbf{This Architecture} & \textbf{Script-Based (LN)} \\
\midrule
Time & $\bigO(k)$ (Native Ops) & $\bigO(k \cdot \textit{size}_{\text{script}})$ \\
Space & $\bigO(1)$ & $\bigO(\textit{stack\_depth})$ \\
Context & Single RefOp & VM Execution Context \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Case Study: Atomic Liquidation in DeFi}

We analyze a liquidation scenario: Pool $P$ must liquidate 100 users $\{U_1, \dots, U_{100}\}$ to Liquidator $L$.

\subsubsection{Traditional vs.\ Atomic Approach}
Traditional LN requires 100 serial payments, risking ``Bad Debt'' if prices drop mid-process. Our architecture uses a \textbf{Star Topology Splice} to execute this atomically.

$$ \tau_{\mathrm{liquidate}}: \{S_{\mathrm{pool}}\} \xrightarrow{\text{Atomic}} \{S'_{\mathrm{pool}}\} $$
where $\mathrm{Bal}'(L) = \mathrm{Bal}(L) + \sum \delta_i$ and $\mathrm{Bal}'(U_i) = \mathrm{Bal}(U_i) - \delta_i$.

\begin{table}[htbp]
\centering
\caption{Liquidation Efficiency Comparison (100 Users)}
\label{tab:liquidation}
\small
\begin{tabularx}{\linewidth}{@{}lXX@{}}
\toprule
\textbf{Metric} & \textbf{Lightning (Serial)} & \textbf{Proposed (Atomic)} \\
\midrule
Complexity & $\bigO(N)$ & $\bigO(1)$ \\
Latency & 30--300s & Sub-second \\
Atomicity & None (Partial Failure) & \textbf{All-or-Nothing} \\
Tx Count & 100 & \textbf{1} \\
Risk & High (Price Slippage) & Zero \\
\bottomrule
\end{tabularx}
\end{table}

This $\bigO(1)$ atomic settlement capability is a prerequisite for high-frequency decentralized finance applications.
