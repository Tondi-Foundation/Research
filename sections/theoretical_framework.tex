\section{Theoretical Framework: Dual-Track State Machines}

\subsection{Finite State Machine Formalization}

The foundation of our theoretical framework rests on modeling payment channels as \textbf{Deterministic Finite Automata (DFA)}. This formalization provides several critical advantages: (1) it enables formal verification of protocol correctness, (2) it establishes a precise vocabulary for reasoning about state transitions, and (3) it maps directly to consensus-layer implementation semantics.

\begin{definition}[Channel as DFA]
We define a payment channel $C$ as a 5-tuple Deterministic Finite Automaton:
$$C \equiv (Q, \Sigma, \delta, q_0, F)$$
where each component captures a distinct aspect of channel behavior.
\end{definition}

A DFA is chosen over non-deterministic alternatives because payment channels require \textbf{unambiguous state evolution}: given any state $q$ and input $\sigma$, the next state must be uniquely determined. This property is essential for consensus---all nodes must agree on channel state without coordination.

\textbf{Component Details}:
\begin{itemize}
    \item \textbf{$Q$}: State space. The complete set of possible channel states, partitioned into four disjoint subsets:
    $$Q = \{q_{init}\} \cup Q_{active} \cup Q_{settling} \cup \{q_{closed}\}$$
    
    \begin{itemize}
        \item $\{q_{init}\}$: Singleton initial state before channel funding. The channel exists only as intent.
        \item $Q_{active} = \{(n, R_b, R_p) \mid n \in \mathbb{N}, R_b \in \{0,1\}^{256}, R_p \in \{0,1\}^{256}\}$ --- Active state set, where $\{0,1\}^{256}$ denotes the 256-bit hash output space. Each active state is a triple containing:
        \begin{itemize}
            \item $n$: Monotonically increasing sequence number (version counter)
            \item $R_b$: Balance commitment root (Merkle root of participant balances)
            \item $R_p$: PTLC commitment root (Merkle root of pending conditional payments)
        \end{itemize}
        \item $Q_{settling} = \{(n, R_b, R_p, t) \mid t \in \mathbb{N}_{DAA}\}$ --- Settlement waiting state set. Extends active states with timestamp $t$ marking when the challenge period began. $\mathbb{N}_{DAA}$ denotes DAG-based difficulty adjustment timestamps.
        \item $\{q_{closed}\}$: Singleton terminal state. Channel funds have been distributed; no further transitions possible.
    \end{itemize}
    
    \item \textbf{$\Sigma$}: Input alphabet. The finite set of events that trigger state transitions:
    $$\Sigma = \{\tau_{fund}, \tau_{update}, \tau_{splice}, \tau_{settle}\} \cup \{\epsilon_{timeout}\}$$
    where $\tau_*$ denotes on-chain transaction types (detailed in Section~\ref{sec:tx-types}), and $\epsilon_{timeout}$ represents the CSV timeout expiration event (not a transaction, but a temporal condition).
    
    \item \textbf{$\delta$}: State transition function. A \textit{partial} function mapping state-input pairs to successor states:
    $$\delta: Q \times \Sigma \rightharpoonup Q$$
    Partiality is essential: not all transitions are valid from all states (e.g., $\tau_{fund}$ is only valid from $q_{init}$).
    
    \item \textbf{$q_0$}: Initial state. $q_0 = q_{init}$. Every channel begins in this pre-funded state.
    
    \item \textbf{$F$}: Final (accepting) state set. $F = \{q_{closed}\}$. A channel in this state has completed its lifecycle.
\end{itemize}

\begin{definition}[State Space Structure]
State space $Q$ constitutes a \textbf{partially ordered set (Poset)} $(Q, \preceq)$, where:
$$q_1 \preceq q_2 \iff n_1 \leq n_2 \land (n_1 = n_2 \Rightarrow q_1 = q_2)$$
This partial order relation guarantees \textbf{monotonicity} and \textbf{determinism} of state evolution.
\end{definition}

\textbf{Interpretation of the Partial Order}:
\begin{itemize}
    \item \textbf{Forward-only evolution}: States can only progress to higher sequence numbers. This prevents ``time-travel'' attacks where adversaries attempt to revert to advantageous historical states.
    \item \textbf{Antisymmetry}: If $q_1 \preceq q_2$ and $q_2 \preceq q_1$, then $q_1 = q_2$. Two distinct states cannot be mutually reachable.
    \item \textbf{Transitivity}: If $q_1 \preceq q_2 \preceq q_3$, then $q_1 \preceq q_3$. State evolution forms a well-ordered chain.
\end{itemize}

This structure is \textit{not} a total order because states with different $(R_b, R_p)$ but the same $n$ are incomparable---they represent mutually exclusive branches that consensus must resolve.

\subsection{State Transition Rules}

The transition function $\delta$ encodes the complete protocol logic. Each rule corresponds to a specific channel operation with precise preconditions and postconditions.

\begin{definition}[Transition Function]
$\delta$ is defined by the following rules, where each transition is annotated with its semantic meaning:

\begin{align*}
\delta(q_{init}, \tau_{fund}) &= q_{active}^{(0)} && \text{[FUND]: Channel creation} \\
\delta(q_{active}^{(n)}, \tau_{update}) &= q_{active}^{(n+k)} && \text{where } k > 0 \quad \text{[UPDATE]: State iteration} \\
\delta(q_{active}^{(n)}, \tau_{splice}) &= \{q_{active}^{(n')}, q_{child}^{(0)}\} && \text{[SPLICE]: Topology reconfiguration} \\
\delta(q_{active}^{(n)}, \tau_{settle}) &= q_{settling}^{(n, t)} && \text{[SETTLE-INIT]: Begin challenge period} \\
\delta(q_{settling}^{(n, t)}, \epsilon_{timeout}) &= q_{closed} && \text{when } t_{now} - t \geq \text{CSV} \quad \text{[SETTLE-FINAL]}
\end{align*}
\end{definition}

\textbf{Detailed Rule Semantics}:

\begin{enumerate}
    \item \textbf{[FUND] --- Channel Creation}:
    \begin{itemize}
        \item \textit{Precondition}: Channel does not exist ($q = q_{init}$)
        \item \textit{Action}: Participants lock funds into a 2-of-2 multisig, creating $U_{fund}$ and $U_{state}^{(0)}$
        \item \textit{Postcondition}: Channel enters active state with sequence number 0
        \item \textit{On-chain cost}: One transaction (funding tx)
    \end{itemize}
    
    \item \textbf{[UPDATE] --- State Iteration}:
    \begin{itemize}
        \item \textit{Precondition}: Channel is active ($q \in Q_{active}$)
        \item \textit{Action}: Participants sign a new state with $n' = n + k$ where $k > 0$
        \item \textit{Key constraint}: $k > 0$ enforces \textbf{strict monotonicity}---this is the core invariant preventing state rollback
        \item \textit{Postcondition}: New state replaces old; old state becomes unspendable
        \item \textit{On-chain cost}: Zero (off-chain signature exchange only)
    \end{itemize}
    
    \item \textbf{[SPLICE] --- Topology Reconfiguration}:
    \begin{itemize}
        \item \textit{Precondition}: Channel is active
        \item \textit{Action}: Spend current fund/state to create new channel configurations (add/remove participants, adjust capacity, spawn child channels)
        \item \textit{Postcondition}: Returns a \textit{set} of new states---this is the only non-deterministic-looking rule, but output set is uniquely determined by transaction content
        \item \textit{On-chain cost}: One transaction (splice tx)
    \end{itemize}
    
    \item \textbf{[SETTLE-INIT] --- Challenge Period Initiation}:
    \begin{itemize}
        \item \textit{Precondition}: Channel is active
        \item \textit{Action}: Any participant broadcasts current state on-chain
        \item \textit{Postcondition}: Channel enters settling phase with timestamp $t$; challenge window opens
        \item \textit{Security note}: During settling, counterparties may submit higher $n$ states to challenge
    \end{itemize}
    
    \item \textbf{[SETTLE-FINAL] --- Channel Closure}:
    \begin{itemize}
        \item \textit{Precondition}: Channel is settling AND challenge period expired ($t_{now} - t \geq \text{CSV}$)
        \item \textit{Action}: Any participant broadcasts the finalization transaction; funds distributed according to final state balances
        \item \textit{Postcondition}: Channel enters terminal $q_{closed}$ state; no further transitions possible
        \item \textit{Note}: $\epsilon_{timeout}$ is a temporal event, not a transaction type---it represents the passage of time past the CSV threshold
    \end{itemize}
\end{enumerate}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=1.8cm,
    font=\sffamily\scriptsize,
    state/.style={circle, draw, thick, minimum size=1.1cm, align=center, fill=white},
    arrow/.style={->, >=Stealth, thick}
]
    \node[state, fill=gray!10] (init) {$q_{\mathrm{init}}$};
    \node[state, fill=green!10, right=of init] (active) {$q_{\mathrm{active}}^{(n)}$};
    \node[state, fill=yellow!10, right=of active] (settling) {$q_{\mathrm{settle}}$};
    \node[state, fill=red!10, right=of settling] (closed) {$q_{\mathrm{closed}}$};
    
    \draw[arrow] (init) -- node[above] {$\tau_{\mathrm{fund}}$} (active);
    \draw[arrow] (active) edge[loop above] node {$\tau_{\mathrm{update}}$} (active);
    \draw[arrow] (active) -- node[above] {$\tau_{\mathrm{settle}}$} (settling);
    \draw[arrow] (settling) -- node[above] {CSV} (closed);
    \draw[arrow] (settling) edge[loop below, dashed] node[align=center] {Challenge\\($n' > n$)} (settling);
\end{tikzpicture}
\caption{Channel State Machine Transitions.}
\label{fig:state-machine}
\end{figure}

\textbf{Challenge Rule}: In $Q_{settling}$ state, higher sequence number states can replace the current claim:
$$\delta(q_{settling}^{(n, t)}, \tau_{challenge}) = q_{settling}^{(n', t')} \quad \text{where } n' > n$$
Note: $\tau_{challenge}$ uses the same transaction format as $\tau_{settle}$ but is semantically a \textit{dispute} rather than an initiation. We distinguish them in the formalism for clarity, though on-chain they share the same structure.

\textbf{Challenge Mechanism Explanation}:
The challenge rule is the core security mechanism that eliminates the need for penalty transactions (toxic waste). During the settling period:
\begin{enumerate}
    \item Any participant holding a state with $n' > n$ can submit it on-chain
    \item The consensus layer verifies $n' > n$ and accepts the newer state
    \item The challenge timer resets to $t'$ (current timestamp)
    \item This process repeats until the challenge period expires without a higher state being submitted
    \item The highest $n$ state at expiration determines final fund distribution
\end{enumerate}

This ``latest state wins'' semantics ensures that even if a malicious party attempts to close with an outdated state, honest parties can always correct the record by submitting the true latest state.

\subsection{UTXO Materialization Layer}

The abstract states of the state machine are materialized on-chain through \textbf{UTXO binary tuples}. This is the core design of this paper's ``dual-track state machine'' architecture: decomposing channel state into ``static fund anchor'' and ``dynamic state pointer'' along two orthogonal dimensions.

\textbf{Design Rationale}:
Traditional payment channel designs conflate fund custody and state versioning into a single UTXO. This creates a fundamental problem: every state update requires conceptually ``moving'' the funds, even though the actual fund distribution hasn't changed. The dual-track architecture separates these concerns:
\begin{itemize}
    \item \textbf{Fund UTXO} (static): Holds the actual funds; rarely changes
    \item \textbf{State UTXO} (dynamic): Tracks version number and balance commitments; changes frequently
\end{itemize}

This separation enables \textit{zero on-chain cost} for state updates: the Fund UTXO remains untouched while only the State UTXO evolves.

% Include dual-track diagram
\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=1.5cm and 2.5cm,
    font=\sffamily\scriptsize,
    box/.style={rectangle, draw=gray, thick, rounded corners, minimum width=2.8cm, minimum height=1.2cm, align=center, fill=white},
    header/.style={font=\bfseries\footnotesize, anchor=south},
    arrow/.style={->, >=Stealth, thick, blue!80!black}
]
    % Static Track
    \node[box, fill=blue!10] (fund) {Fund UTXO\\(Static Anchor)};
    \node[below=0.2cm of fund, align=center, font=\tiny] (fund-content) {Cap: $V$ \quad Keys: $K_p$\\AggVK};
    \node[header] at (fund.north) [yshift=0.3cm] {Static Track};
    
    % Dynamic Track
    \node[box, fill=green!10, right=of fund] (state) {State UTXO\\(Dynamic Pointer)};
    \node[below=0.2cm of state, align=center, font=\tiny] (state-content) {Seq: $n$ \quad Balances: $R_b$\\PTLC Root: $R_p$};
    \node[header] at (state.north) [yshift=0.3cm] {Dynamic Track};
    
    % RefOp Operator
    \draw[arrow, dashed] (state) -- node[above, font=\tiny] {$\RefOp$ (Read-Only)} (fund);
\end{tikzpicture}
\caption{Dual-Track State Machine. Separation of static funding capability from dynamic state evolution.}
\label{fig:dual-track}
\end{figure}

\textbf{Mathematical Formalization}:
$$\calM: Q_{active} \to \calU \times \calU$$
$$\calM(q) = \langle \underbrace{U_{fund}}_{\text{static anchor}}, \underbrace{U_{state}^{(n)}}_{\text{dynamic pointer}} \rangle$$
Here $\calM$ maps each active state to a \textit{pair} of UTXOs (not a set), reflecting the dual-track architecture's core invariant: one fund, one state.

\textbf{Semantic Interpretation}:
\begin{table}[htbp]
\centering
\small
\caption{Dual-Track Model Components}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Component} & \textbf{Role} & \textbf{Characteristics} & \textbf{Function} \\
\midrule
$U_{fund}$ & Static anchor & Invariant & Carries funds, identity, keys \\
$U_{state}^{(n)}$ & Dynamic pointer & Evolves with state & Carries sequence, balances, PTLCs \\
\bottomrule
\end{tabular}
\end{table}

Where:
\begin{itemize}
    \item \textbf{$U_{fund}$}: Static Anchor
    \begin{itemize}
        \item Carries funds $V \in \mathbb{N}$
        \item Identifies channel identity $ID_C = H(\text{domain} \| \text{funding\_outpoint} \| ...)$
        \item Stores participant key set $K_p = \{pk_1, ..., pk_m\}$
        \item Aggregated verification key $AggVK = \text{MuSig2}(K_p)$
    \end{itemize}
    
    \item \textbf{$U_{state}^{(n)}$}: Dynamic Pointer
    \begin{itemize}
        \item State sequence number $n \in \mathbb{N}$
        \item Balance commitment $R_b = \text{MerkleRoot}(\{\text{balance}_i\})$
        \item PTLC commitment $R_p = \text{MerkleRoot}(\{\text{ptlc}_j\})$
        \item Creation timestamp $t_{create} \in \mathbb{N}_{DAA}$
    \end{itemize}
\end{itemize}

\begin{definition}[RefOp-Fund Semantics]
Read-only reference operator $\RefOp: \calU \to \calU^{readonly}$:
$$\RefOp(U_{fund}) \triangleq \langle U_{fund}.\text{outpoint}, U_{fund}.\text{metadata} \rangle$$
Satisfies: $\forall \tau: \RefOp(U) \in \text{inputs}(\tau) \Rightarrow U \in \text{UTXO\_Set}_{\text{post}(\tau)}$
\end{definition}

\textbf{RefOp Semantics Explanation}:
The $\RefOp$ operator is a novel consensus primitive that enables \textit{read-without-consume} access to UTXOs. This is fundamentally different from traditional UTXO spending:

\begin{itemize}
    \item \textbf{Traditional Spend}: $\Spend(U) \implies U \notin \text{UTXO\_Set}_{post}$ (UTXO is consumed)
    \item \textbf{RefOp Reference}: $\RefOp(U) \implies U \in \text{UTXO\_Set}_{post}$ (UTXO persists)
\end{itemize}

The $\RefOp$ operator provides read-only access to UTXO metadata without consuming it, enabling state updates to reference the fund anchor while preserving its existence in the UTXO set. This creates a \textit{persistent identity anchor} for the channel that survives arbitrarily many state updates.

\textbf{Practical Implications}:
\begin{enumerate}
    \item \textbf{Efficiency}: State updates don't require fund movement, reducing transaction size
    \item \textbf{Atomicity}: Fund and state can be spent together in SETTLE/SPLICE, ensuring atomic closure
    \item \textbf{Verification}: Validators can verify state belongs to a specific channel by checking RefOp linkage
\end{enumerate}

\subsubsection{State-Fund Coupling Invariant}

\textbf{Invariant}: At any moment, there exists a unique pairing of $(U_{fund}, U_{state})$ for each channel:
$$\forall t, \exists! (U_{fund}, U_{state}) \in \calU_{set} \text{ s.t. } ID(U_{fund}) = ID(U_{state})$$

This invariant ensures that even during frequent \texttt{UPDATE} operations, the Fund layer maintains static anchoring while the State layer carries high-frequency changes. Their lifecycles only experience \textbf{physical convergence} during \texttt{SPLICE} or \texttt{SETTLE}.

\textbf{Invariant Properties}:
\begin{enumerate}
    \item \textbf{Existence}: Every active channel has exactly one fund UTXO and one state UTXO
    \item \textbf{Uniqueness}: The channel ID deterministically links exactly one fund to one state
    \item \textbf{Temporal Stability}: The fund UTXO persists across all UPDATE operations
    \item \textbf{Eventual Convergence}: Only SPLICE or SETTLE consume the fund UTXO
\end{enumerate}

\textbf{Why This Matters}:
Traditional single-UTXO designs require the same UTXO to be spent and recreated for every state update, creating $O(n)$ on-chain footprint for $n$ updates. The dual-track design achieves $O(1)$ on-chain footprint: the fund UTXO is created once at FUND and consumed once at SETTLE, regardless of how many state updates occur in between.

\subsection{Consensus-Layer Embedded Verification Mechanism}
\label{sec:tx-types}

Unlike traditional payment channel protocols that rely on complex scripts for state verification, this architecture \textit{enshrines} channel semantics directly into the consensus layer. This design choice has profound implications for security, performance, and formal verifiability.

\textbf{Key Design Principles}:
\begin{enumerate}
    \item \textbf{Type-Driven Verification}: Transaction types are determined by I/O topology, not runtime script execution
    \item \textbf{Compile-Time Safety}: Invalid state transitions are rejected at deserialization, before entering the validation engine
    \item \textbf{Constant-Time Classification}: $O(1)$ pattern matching replaces $O(\text{script\_size})$ interpretation
\end{enumerate}

\subsubsection{Transaction Type Enumeration and Pattern Matching}

This paper's architecture employs consensus-layer native transaction type enumeration, replacing traditional script parsing methods, achieving $\bigO(1)$ time complexity pattern matching verification. Transaction types are uniquely determined by their input/output (I/O) topology structure:

\textbf{Why I/O Topology Suffices}:
Each Eltoo transaction type has a distinct ``shape'' defined by:
\begin{itemize}
    \item Which input types it consumes (Spend) or references (Ref)
    \item Which output types it produces
\end{itemize}
This shape is sufficient to classify any transaction without examining script content. The classification is \textit{syntax-directed}: the validator inspects the transaction structure, not its embedded logic.

\begin{table}[htbp]
\centering
\small
\caption{Transaction Type Enumeration System}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Tx Type} & \textbf{Input Pattern} & \textbf{Output Pattern} & \textbf{Semantics} \\
\midrule
\texttt{FUND} & $\emptyset_{eltoo}$ & $\{U_{fund}, U_{state}^{(0)}\}$ & Create channel \\
\texttt{UPDATE} & $\{\RefOp(U_{fund}), \Spend(U_{state}^{(n)})\}$ & $\{U_{state}^{(n')}\}$ & State iteration \\
\texttt{SETTLE} & $\{\Spend(U_{fund}), \Spend(U_{state}^{(n)})\}$ & $\notin \calU_{eltoo}$ & Settlement \\
\texttt{SPLICE} & $\{\Spend(U_{fund}), \Spend(U_{state}^{(n)})\}$ & $\{U_{fund}', U_{state}', ...\}$ & Topology transform \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=0.8cm and 0.6cm,
    font=\sffamily\scriptsize,
    box/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=1cm, align=center, fill=white},
    arrow/.style={->, >=Stealth, thick}
]
    % Validator Core
    \node[rectangle, draw, fill=gray!10, minimum width=10.5cm, minimum height=0.7cm, rounded corners] (validator) {Eltoo Consensus Validator ($\mathcal{O}(1)$ Pattern Matching)};
    
    % Types
    \node[box, fill=orange!10, below=1cm of validator.south west, anchor=west, xshift=0.3cm] (fund) {\textbf{FUND}\\Create Channel};
    \node[box, fill=blue!10, right=0.6cm of fund] (update) {\textbf{UPDATE}\\Iterate State};
    \node[box, fill=green!10, right=0.6cm of update] (settle) {\textbf{SETTLE}\\Close Channel};
    \node[box, fill=purple!10, right=0.6cm of settle] (splice) {\textbf{SPLICE}\\Reconfigure};
    
    % Arrows
    \foreach \x in {fund, update, settle, splice} {
        \draw[arrow] (validator.south -| \x.north) -- (\x.north);
    }
\end{tikzpicture}
\caption{Transaction Type Enumeration System. The consensus layer classifies transactions via $\mathcal{O}(1)$ pattern matching on I/O topology.}
\label{fig:tx-types}
\end{figure}

\subsubsection{State Monotonicity Theorem and Consensus Implementation}

\begin{theorem}[Consensus-Level Monotonicity Guarantee]
Under this paper's consensus rules, channel state sequence number $n$ satisfies strict monotonically increasing constraint.
$$\forall \tau_{update}: U_{state}^{(n)} \xrightarrow{\tau} U_{state}^{(n')} \implies n' > n$$
\end{theorem}

This formula states that for any update transaction $\tau_{update}$, if it transforms state UTXO from version $n$ to version $n'$, then $n'$ must be strictly greater than $n$. This constraint fundamentally prevents state rollback attacks.

\begin{proof}
The consensus validator \texttt{EltooBlockValidator} performs the following atomic checks:

\begin{enumerate}
    \item \textbf{Parsing Phase}: Extract $U_{state}^{(n)}$ from $\tau_{update}$ inputs, extract $U_{state}^{(n')}$ from outputs
    
    \item \textbf{Monotonicity Check}: 
    $$\text{if } n' \leq n \implies \text{reject with } \texttt{ConsensusError::NonMonotonicState}$$
    
    \item \textbf{UTXO One-Time Consumption}: Due to blockchain immutability and UTXO one-time consumption property, once $\tau_{update}$ is on-chain, old state $U_{state}^{(n)}$ is consumed and cannot be used as input again
    
    \item \textbf{Physical Defense}: Physically prevents state rollback attacks at the protocol layer
\end{enumerate}

Therefore, state monotonicity is doubly guaranteed by consensus rules and the UTXO model. \
\end{proof}

\subsubsection{Consensus Verification Performance Analysis}

Transaction types are identified via pattern matching ($\bigO(1)$), monotonicity is checked via integer comparison ($\bigO(1)$), and signatures are verified via aggregation ($\bigO(1)$ amortized with batch verification). The only $\bigO(\log N)$ component is UTXO set lookup, which is unavoidable in any UTXO-based system. Thus, the \textbf{Eltoo-specific} verification overhead is $\bigO(1)$, while total verification complexity (including UTXO lookup) is $\bigO(\log N)$. Compared to Script-based solutions' $\bigO(\text{script\_size} + \log N)$, we eliminate the script interpretation overhead entirely.

\textbf{Measured Performance} (based on testnet data, December 2025):

\begin{table}[htbp]
\centering
\small
\caption{Consensus Verification Latency}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Operation} & \textbf{Latency} & \textbf{Includes} \\
\midrule
Fund Verification & 0.12 ms & MuSig2 aggregate verification \\
Update Verification & 0.08 ms & Monotonicity + Ref check + signature \\
Settle Verification & 0.35 ms & PTLC verification + CSV check \\
Splice Verification & 0.28 ms & Value conservation + topology integrity \\
\bottomrule
\end{tabular}
\end{table}

\begin{corollary}[Scalability]
Due to constant-level verification complexity, full nodes can verify blocks containing 10,000+ Eltoo transactions within 1 second.
\end{corollary}

\subsubsection{Ref-UTXO Atomicity and Ordering in GhostDAG}

Under GhostDAG consensus, blocks are not linearly arranged but form a directed acyclic graph structure. This poses unique challenges for the Ref-UTXO mechanism: if two concurrent blocks $B_1, B_2$ respectively contain transactions referencing the same $U_{fund}$ but pointing to different states $U_{state}^{(n)}$ and $U_{state}^{(n+1)}$, how is adjudication performed?

\begin{definition}[DAG Topological Ordering Rule]
Let $\prec_{DAG}$ be the total order computed by GhostDAG. For any transaction pair $\tau_a, \tau_b$ referencing the same $U_{fund}$:
\begin{enumerate}
    \item \textbf{Exclusive Write}: If both $\tau_a, \tau_b$ are \texttt{UPDATE} operations, they are ordered by $\prec_{DAG}$; only the earlier transaction is valid, the latter is treated as double-spend conflict
    \item \textbf{Concurrent Read}: If $\tau_a, \tau_b$ only perform \texttt{Ref} reads on $U_{fund}$ (e.g., operations in different sub-channels) and don't conflict on the same $U_{state}$, they are allowed to coexist concurrently in the anticone
\end{enumerate}
\end{definition}

\textbf{DAG Ordering Explanation}:
Unlike Bitcoin's linear blockchain, GhostDAG produces a \textit{partial order} on blocks that is then extended to a total order. This creates a unique challenge: what happens when two miners simultaneously include conflicting Eltoo transactions?

\begin{itemize}
    \item \textbf{Anticone}: Blocks that are neither ancestors nor descendants of each other. They represent concurrent mining activity.
    \item \textbf{Conflict Resolution}: When conflicting \texttt{UPDATE} transactions appear in the anticone, GhostDAG's ordering algorithm deterministically selects one as ``first,'' invalidating the other.
    \item \textbf{Read Concurrency}: Non-conflicting \texttt{Ref} operations can coexist, enabling parallel channel operations.
\end{itemize}

\begin{definition}[Active State Lease]
We introduce the concept of \textbf{Active State Lease} in the UTXO set:
$$\text{Lease}: \calU_{fund} \to \text{TxID}(\tau_{last\_valid\_update})$$
Verification nodes maintain this mapping, ensuring state updates for a specific $U_{fund}$ are linearized on any DAG cut.
\end{definition}

The $\text{Lease}$ function maps each Fund UTXO to its most recent valid update transaction, preventing concurrent conflicts in the DAG environment.

\begin{theorem}[DAG State Convergence]
Under GhostDAG's $(D, k)$ parameters, channel state fork probability decays exponentially with time:
$$P(\text{state fork at depth } d) \leq e^{-\lambda d}$$
where $\lambda$ is a convergence constant positively correlated with parameter $k$.
\end{theorem}

\begin{proof}[Proof (Outline)]
\begin{enumerate}
    \item GhostDAG guarantees anticone size at depth $d$ is less than $k$ with high probability
    \item Since \texttt{UPDATE} transactions consume the unique $U_{state}^{(n)}$, any concurrent update attempts will have one rejected after DAG ordering
    \item Combined with the lease mechanism, honest nodes reach consensus on the latest state in $\bigO(\frac{D}{k})$ time
\end{enumerate}
\end{proof}

\begin{table}[htbp]
\centering
\small
\caption{Concurrent Safety Analysis}
\begin{tabular}{@{}llp{5cm}@{}}
\toprule
\textbf{Operation Type} & \textbf{Concurrency Situation} & \textbf{Handling Strategy} \\
\midrule
\texttt{UPDATE} vs \texttt{UPDATE} & Same $U_{state}$ & DAG ordering, latter invalid \\
\texttt{UPDATE} vs \texttt{SETTLE} & Same $U_{state}$ & DAG ordering, latter invalid \\
\texttt{Ref} vs \texttt{Ref} & Same $U_{fund}$, different $U_{state}$ & Concurrent allowed \\
\texttt{Ref} vs \texttt{Spend} & Same $U_{fund}$ & \texttt{Spend} invalidates $U_{fund}$, subsequent \texttt{Ref} invalid \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Temporal Decoupling of Cross-Block State References}

In GhostDAG's high-concurrency environment, requiring \texttt{SETTLE} transactions and their referenced \texttt{UPDATE} anchor transactions to be in the same block is neither realistic nor efficient. This architecture implements \textbf{Cross-Block State Anchoring}.

\begin{definition}[Valid Reference Window]
Let $\tau_{update}$ be confirmed in block $B_i$, generating $U_{state}^{(n)}$.
Let $\tau_{settle}$ be broadcast in block $B_j$, referencing $U_{state}^{(n)}$.
$\tau_{settle}$ is valid if and only if:
\begin{enumerate}
    \item $B_i \in \text{Past}(B_j)$ (DAG topological order)
    \item $U_{state}^{(n)}$ is in ``unspent'' status in $B_j$'s UTXO view set
\end{enumerate}
\end{definition}

\begin{theorem}[Anchoring Persistence]
As long as no new \texttt{UPDATE} transaction $\tau_{update}'$ overwrites $U_{state}^{(n)}$, that state UTXO will persist in the ledger:
$$\forall t \geq t_{confirm}: \bigl(\nexists \tau_{update}' \in \text{Chain}(t) : \tau_{update}'.\text{input} = U_{state}^{(n)}\bigr) \implies U_{state}^{(n)} \in \calU_{chain}(t)$$
\end{theorem}

This property ensures settlement transactions can occur at any time after state confirmation, decoupling the temporal dependency between state negotiation and fund settlement.

\subsubsection{Algebraic Data Type Definition of Transaction Classification}

To eliminate ambiguity and transaction malleability risks in traditional script language (Script-based) runtime parsing, this architecture introduces an \textbf{Enshrined Transaction Enums} system, pushing transaction type verification from Turing-complete script execution down to static type system checking.

\begin{definition}[Typed Input/Output Spaces]
Define input set $\mathcal{I}$ and output set $\mathcal{O}$ as algebraic sum types with variant tags:
$$\mathcal{I} = \{\text{Std}, \text{FundSpend}, \text{StateSpend}, \text{FundRef}, \text{IngotSpend}, \text{IngotRef}\}$$
$$\mathcal{O} = \{\text{Std}, \text{ChannelFund}, \text{ChannelState}, \text{Ingot}\}$$
where $\text{FundRef}$ is a special unit type with semantics $\tau \to \bot$ (non-spendable), serving only as an oracle providing metadata access to $U_{fund}$.
\end{definition}

\begin{definition}[Type Inference Homomorphism]
Define function $\Gamma: \mathcal{I}^* \times \mathcal{O}^* \to \mathcal{T}_{Eltoo} \cup \{\bot\}$, which maps transaction I/O topology to semantic types in $\bigO(1)$ time complexity:
$$
\Gamma(In, Out) = \begin{cases} 
  \texttt{FUND} & \text{if } Out \cong \{\text{ChannelFund}, \text{ChannelState}\} \land In \cap \mathcal{I}_{eltoo} = \emptyset \\ 
  \texttt{UPDATE} & \text{if } In \cong \{\text{FundRef}, \text{StateSpend}\} \land Out \cong \{\text{ChannelState}\} \\ 
  \texttt{SETTLE} & \text{if } In \cong \{\text{FundSpend}, \text{StateSpend}\} \land Out \cap \mathcal{O}_{eltoo} = \emptyset \\ 
  \texttt{SPLICE} & \text{if } In \cong \{\text{FundSpend}, \text{StateSpend}\} \land Out \cap \{\text{ChannelFund}\} \neq \emptyset \\
  \bot & \text{otherwise}
\end{cases}
$$
\end{definition}

\textbf{Pattern Matching Rules}:
\begin{itemize}
    \item \textbf{FUND}: Input contains no Eltoo types, output contains Fund + State UTXOs
    \item \textbf{UPDATE}: Input is ``Ref Fund + Spend State'', output is new State UTXO
    \item \textbf{SETTLE}: Input is ``Spend Fund + Spend State'', output contains no Eltoo types (funds distributed to participants)
    \item \textbf{SPLICE}: Same input as SETTLE, but output contains new Fund UTXO (topology reconfiguration)
    \item \textbf{$\bot$}: Matches no pattern, transaction rejected
\end{itemize}

\begin{theorem}[Compile-Time Safety Guarantee]
Under Rust's type system guarantees, there are no Eltoo transactions in ``undefined states.'' Due to Rust enum's \textbf{exhaustiveness check}, the compiler forces handling of all $\Gamma$ matching branches. Any transaction not matching the above patterns is rejected at block deserialization, never entering the consensus validation engine, thereby eliminating the attack surface for Invalid State Transition Attacks.
\end{theorem}

\begin{table}[htbp]
\centering
\small
\caption{Type System Implementation Mapping}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Type Theory Concept} & \textbf{Rust Implementation} & \textbf{Consensus Semantics} \\
\midrule
Sum Type $\mathcal{I}$ & \texttt{enum EltooInput} & Input variant classification \\
Sum Type $\mathcal{O}$ & \texttt{enum EltooOutput} & Output variant classification \\
$\Gamma$ function & \texttt{EltooTxType::classify()} & $\bigO(1)$ pattern matching \\
$\bot$ case & \texttt{ConsensusError::InvalidEltooTxType} & Reject invalid transactions \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Transaction Semantics Mapping}

This section establishes the formal correspondence between abstract state machine transitions and their concrete UTXO-level implementations. Each transition rule from Section~4.2 is mapped to specific input/output patterns and verification conditions.

\textbf{Notation Convention}:
\begin{itemize}
    \item $\RefOp(U)$: Read-only reference to UTXO $U$ (does not consume)
    \item $\Spend(U)$: Consume UTXO $U$ (removes from UTXO set)
    \item $\to$: Transaction produces outputs
    \item $AggVK$: Aggregated verification key from MuSig2
    \item $H(\cdot)$: Cryptographic hash function
\end{itemize}

Mapping between abstract transitions and concrete UTXO operations:

\textbf{Fund Transaction}:
\begin{align*}
\tau_{fund}&: \{U_{wallet}\} \to U_{fund} \cup U_{state}^{(0)} \\
\calM^{-1}(\tau_{fund}) &= \delta(q_{init}, \tau_{fund})
\end{align*}

\textit{Explanation}: The FUND transaction consumes one or more wallet UTXOs (standard spendable outputs) and produces two outputs: the Fund UTXO (static anchor carrying the channel's value) and the initial State UTXO with sequence number 0. The inverse materialization function $\calM^{-1}$ maps this concrete transaction back to the abstract state transition.

\textbf{Update Transaction}:
\begin{align*}
\tau_{update}&: \{\RefOp(U_{fund}), \Spend(U_{state}^{(n)})\} \to U_{state}^{(n+k)} \\
\text{Precondition: } &\exists \sigma: \text{Verify}(AggVK, \sigma, H(\text{state}_{n+k} \| \text{RefOp\_OutPoint}))
\end{align*}

\textit{Explanation}: The UPDATE transaction demonstrates the core dual-track innovation. It \textit{references} the Fund UTXO (via RefOp) and \textit{spends} the current State UTXO, producing a new State UTXO with higher sequence number. The precondition requires a valid MuSig2 signature over the new state concatenated with the Fund UTXO's outpoint (for binding). Critically, the Fund UTXO is \textbf{not consumed}---it persists in the UTXO set.

\textbf{Splice Transaction}:
\begin{align*}
\tau_{splice}&: \{\Spend(U_{fund}^{parent}), \Spend(U_{state}^{(n)})\} \to \{U_{fund}^{parent'}, U_{state}^{(n)'}, U_{fund}^{child_1}, ...\} \\
\text{Invariant: } &V(U_{fund}^{parent}) = V(U_{fund}^{parent'}) + \sum_i V(U_{fund}^{child_i})
\end{align*}

\textit{Explanation}: SPLICE is the only operation that \textit{spends} the Fund UTXO. It enables topology reconfiguration: adding/removing participants, adjusting channel capacity, or spawning child channels. The value conservation invariant ensures no funds are created or destroyed---the parent's value is redistributed among the new fund outputs. This is a powerful primitive enabling hierarchical channel networks.

\textbf{Settle Transaction}:
\begin{align*}
\tau_{settle}&: \{\Spend(U_{fund}), \Spend(U_{state}^{(n)})\} \xrightarrow{\Delta t \geq \text{CSV}} \{U_{out}^{(i)}\} \\
\text{where } &\Delta t = \text{DAA}_{current} - \text{DAA}_{\text{state\_creation}}
\end{align*}

\textit{Explanation}: The SETTLE transaction closes the channel. It spends both the Fund and State UTXOs, distributing funds to participants according to the balance commitments in the final state. The CSV (CheckSequenceVerify) timelock ensures a challenge period has elapsed, allowing counterparties to dispute with newer states. The $\Delta t$ calculation uses DAA (Difficulty Adjustment Algorithm) timestamps for time measurement in the DAG context.

\subsection{Formal Safety Properties}

The following properties characterize the correctness of the dual-track state machine. Each property can be formally verified through TLA+ model checking or Coq proof assistants. Together, they guarantee that the protocol behaves as intended under all possible execution paths.

\begin{theorem}[Monotonicity]
$$\forall q_1, q_2 \in Q_{active}: \delta^*(q_1, w) = q_2 \Rightarrow q_1 \preceq q_2$$
where $\delta^*$ is the transitive closure of $\delta$, and $w \in \Sigma^*$ is a transaction sequence.
\end{theorem}

\textit{Interpretation}: Starting from any active state $q_1$, any sequence of valid transitions leads to a state $q_2$ that is ``ahead of'' $q_1$ in the partial order. This means state evolution is \textbf{irreversible}: once a state with sequence number $n$ is reached, no valid transition sequence can return to a state with sequence number $< n$.

\begin{proof}
By inductive proof using constraint $k > 0$ from transition rule [UPDATE].
\begin{enumerate}
    \item \textbf{Base case}: For any single transition $\delta(q_1, \tau) = q_2$:
    \begin{itemize}
        \item If $\tau = \tau_{update}$: $n_2 = n_1 + k > n_1$ by rule constraint
        \item If $\tau = \tau_{settle}$: Settling state includes $n_1$, preserving order
        \item Other transitions preserve or increase sequence number
    \end{itemize}
    \item \textbf{Inductive step}: If $q_1 \preceq q_2$ and $\delta(q_2, \tau) = q_3$, then by base case $q_2 \preceq q_3$, hence by transitivity $q_1 \preceq q_3$.
\end{enumerate}
\end{proof}

\begin{theorem}[Termination]
$$\forall q \in Q \setminus F: \exists w \in \Sigma^*: \delta^*(q, w) \in F$$
Any non-final state has a path to reach a final state.
\end{theorem}

\textit{Interpretation}: The protocol never ``gets stuck.'' From any state (except the terminal $q_{closed}$), there exists a valid sequence of transitions that leads to channel closure. This ensures liveness: users can always recover their funds.

\begin{proof}
Constructive proof---for any state, we exhibit a concrete path to $q_{closed}$:
\begin{enumerate}
    \item From $q_{init}$: Execute $\tau_{fund}$ to reach $q_{active}^{(0)}$
    \item From any $q_{active}^{(n)}$: Execute $\tau_{settle}$ to reach $q_{settling}^{(n,t)}$
    \item From any $q_{settling}^{(n,t)}$: Wait for CSV timeout, then execute $\tau_{timeout}$ to reach $q_{closed}$
\end{enumerate}
The sequence $\tau_{settle} \cdot \tau_{timeout}$ always leads any active state to closure. \qed
\end{proof}

\begin{theorem}[Unambiguity]
$$\forall q \in Q, \forall \sigma \in \Sigma: |\{q' \mid \delta(q, \sigma) = q'\}| \leq 1$$
The transition function is deterministic (single-valued partial function).
\end{theorem}

\textit{Interpretation}: Given a state and a transaction, there is \textbf{at most one} valid successor state. This is essential for consensus: all nodes observing the same transaction must compute the same next state. The $\leq 1$ (rather than $= 1$) accounts for invalid transitions, where $\delta$ is undefined.

\textbf{Note on SPLICE}: While SPLICE produces a \textit{set} of outputs, the transition is still deterministic: the set is uniquely determined by the transaction content. There is exactly one valid output set for any given SPLICE transaction.

\begin{theorem}[Value Conservation]
$$\forall \tau \in \Sigma: \sum_{U \in \text{inputs}(\tau)} V(U) = \sum_{U \in \text{outputs}(\tau)} V(U) + \text{fee}(\tau)$$
\end{theorem}

\textit{Interpretation}: Funds cannot be created or destroyed---only transferred. The total value entering a transaction (from spent UTXOs) equals the total value exiting (to new UTXOs) plus the miner fee. This is the UTXO model's fundamental conservation law, inherited and enforced by the Eltoo protocol.

\subsection{Evolution of Conditional Payment Primitives: From HTLC to PTLC}

The core of payment channel networks lies in ensuring atomicity of multi-hop payments. This mechanism has undergone a paradigm shift from hash-based locking to algebraic homomorphic locking. This section traces this evolution and explains why PTLC represents a fundamental improvement over HTLC.

\textbf{The Multi-Hop Payment Problem}:
When Alice wants to pay Carol through an intermediary Bob, the protocol must ensure:
\begin{enumerate}
    \item \textbf{Atomicity}: Either all hops complete, or none do
    \item \textbf{No trust}: Intermediaries cannot steal funds
    \item \textbf{Privacy}: Observers should not correlate payment paths
\end{enumerate}

Both HTLC and PTLC solve (1) and (2), but only PTLC adequately addresses (3).

\subsubsection{Historical Evolution}

\textbf{HTLC (Hash Time-Locked Contracts, 2016)}: The original Lightning Network mechanism.
\begin{itemize}
    \item \textbf{Mechanism}: Funds are locked by a hash $H = \text{SHA256}(R)$. The recipient reveals preimage $R$ to claim.
    \item \textbf{Atomicity}: Knowing $R$ at any hop enables claiming at all hops (same hash everywhere)
    \item \textbf{Critical Defect}: The same hash $H$ traverses the entire path, allowing correlation attacks:
    \begin{itemize}
        \item \textit{Wormhole Attack}: Colluding nodes at positions $i$ and $j$ can observe the same $H$ and deduce they're on the same payment path
        \item \textit{Payment Correlation}: Any observer seeing the same $H$ on different channels knows they're part of one logical payment
    \end{itemize}
\end{itemize}

\textbf{PTLC (Point Time-Locked Contracts, 2019+)}: The privacy-preserving successor.
\begin{itemize}
    \item \textbf{Mechanism}: Funds are locked by an elliptic curve point $Q = s \cdot G$ where $s$ is a secret scalar and $G$ is the generator point
    \item \textbf{Mathematical Foundation}: Relies on the Elliptic Curve Discrete Logarithm Problem (ECDLP)---given $Q$, computing $s$ is computationally infeasible
    \item \textbf{Key Advantage}: Uses \textbf{additive homomorphism} ($Q_{total} = \sum Q_i$) to blind payment paths
    \item \textbf{How Blinding Works}: Each intermediary adds a random blinding factor:
    $$Q'_i = Q + r_i \cdot G$$
    This transforms the lock at each hop, making locks at different hops \textit{unlinkable}
\end{itemize}

\subsubsection{Technical Principle Comparison}

Figure~\ref{fig:multi_hop_blinding} illustrates the fundamental difference in path privacy.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    font=\sffamily\scriptsize,
    party/.style={circle, draw, minimum size=0.9cm, fill=blue!5, inner sep=1pt},
    arrow/.style={->, >=Stealth, thick}
]
    % HTLC Path
    \node[anchor=west, font=\bfseries] at (-0.5, 2.8) {HTLC: Static Hash (Traceable)};
    \node[party] (a1) at (0, 1.8) {A};
    \node[party, right=of a1] (b1) {B};
    \node[party, right=of b1] (c1) {C};
    \node[party, right=of c1] (d1) {D};
    
    \draw[arrow, red] (a1) -- node[above, font=\tiny] {$H(R)$} (b1);
    \draw[arrow, red] (b1) -- node[above, font=\tiny] {$H(R)$} (c1);
    \draw[arrow, red] (c1) -- node[above, font=\tiny] {$H(R)$} (d1);
    
    \node[right=0.2cm of d1, text=red!70!black, align=left, font=\tiny] {Observer sees\\same $H(R)$};

    % PTLC Path
    \node[anchor=west, font=\bfseries] at (-0.5, 0.5) {PTLC: Blinded Points (Private)};
    \node[party] (a2) at (0, -0.5) {A};
    \node[party, right=of a2] (b2) {B};
    \node[party, right=of b2] (c2) {C};
    \node[party, right=of c2] (d2) {D};
    
    \draw[arrow, blue] (a2) -- node[above, font=\tiny] {$Q_1$} (b2);
    \draw[arrow, blue] (b2) -- node[above, font=\tiny] {$Q_2{=}Q_1{+}r_2G$} (c2);
    \draw[arrow, blue] (c2) -- node[above, font=\tiny] {$Q_3{=}Q_2{+}r_3G$} (d2);
    
    \node[right=0.2cm of d2, text=blue!70!black, align=left, font=\tiny] {Each hop sees\\random $Q_i$};
\end{tikzpicture}
\caption{Multi-Hop Blinding Comparison. HTLC exposes the same hash $H(R)$ globally, while PTLC blinds the lock $Q_i$ at each hop via homomorphic addition.}
\label{fig:multi_hop_blinding}
\end{figure}

\textbf{HTLC: Rigid Locking}. $y = H(x)$. The lock condition is invariant, leaking privacy.

\textbf{PTLC: Algebraic Locking}. $Q = s \cdot G$. Intermediate nodes add random blinding factors $r_i$:
$$ Q'_i = Q + r_i \cdot G \iff s'_i = s + r_i $$
External observers see uncorrelated random points at each hop.

\subsubsection{Core Properties Comparison}

\begin{table}[htbp]
\centering
\caption{HTLC vs. PTLC Feature Comparison}
\label{tab:htlc_ptlc}
\small
\begin{tabularx}{\linewidth}{@{}l X X@{}}
\toprule
\textbf{Feature} & \textbf{HTLC} & \textbf{PTLC} \\
\midrule
Privacy & Weak (Correlatable) & \textbf{Strong (Blinded)} \\
Verify Cost & $\mathcal{O}(\text{ScriptSize})$ & $\mathbf{\mathcal{O}(1)}$ \\
Batching & No & \textbf{Yes (Schnorr)} \\
On-chain & High (32B Preimage) & \textbf{Low (Sig Adapt)} \\
Math & One-way Hash & \textbf{Homomorphic} \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection{Formal Security Analysis}

\begin{theorem}[PTLC Redemption Uniqueness]
Under ECDLP hardness, the scalar $s$ is the unique redemption credential:
$$ \forall Q \in \mathcal{E}: \exists! s \in \mathbb{Z}_n: Q = s \cdot G $$
\end{theorem}

\begin{theorem}[Multi-Hop Atomicity]
For path $c_1 \to \dots \to c_n$, claiming funds at $c_n$ reveals $s$, enabling all previous hops to claim:
$$ \text{Claim}(c_n) \implies \text{Claim}(c_1) $$
\end{theorem}

\begin{theorem}[Timeout Refund Safety]
If no claim occurs before CSV timeout, funds are recoverable:
$$ t_{\mathrm{now}} - t_{\mathrm{create}} \ge \text{CSV} \implies \text{Refund}(\text{sender}) $$
\end{theorem}

\subsubsection{Implementation Considerations}

The PTLC mechanism integrates seamlessly with the dual-track architecture through the following design:

\textbf{PTLC State Encoding}: Each PTLC is stored in the State UTXO's commitment tree:
\begin{itemize}
    \item \textbf{Point Lock} $Q$: The elliptic curve point locking the funds
    \item \textbf{Amount}: Value locked in this PTLC
    \item \textbf{Timeout}: CSV value for refund path
    \item \textbf{Direction}: Incoming or outgoing relative to channel balance
\end{itemize}

\textbf{Claim Verification Logic}:

\begin{lstlisting}[language=Rust, caption={PTLC Claim Verification Logic}, label={lst:ptlc_claim}]
/// Verify s * G + P_beneficiary == Q
/// 
/// This function checks that the claimer knows the discrete log
/// of the point lock minus their public key. This proves:
/// 1. The claimer knows secret s (payment proof)
/// 2. The claim is bound to their identity (P_beneficiary)
fn verify_ptlc_claim(
    point_lock: &Point,      // Q: the lock point
    scalar: &Scalar,         // s: the revealed secret
    beneficiary: &Point,     // P_ben: claimer's public key
) -> bool {
    // Compute s * G + P_beneficiary
    let computed = scalar * &GENERATOR + beneficiary;
    // Must equal the original lock point Q
    computed == *point_lock
}
\end{lstlisting}

\textbf{Why This Works}:
The PTLC is created as $Q = s \cdot G + P_{beneficiary}$. To claim, the beneficiary must reveal $s$. Since only the intended recipient knows the relationship between $Q$, $s$, and their key, only they can construct a valid claim. The verification is a single elliptic curve multiplication and addition---$O(1)$ complexity.

\subsection{TLA+ Specification Fragment}

We formalize the channel state machine using TLA+ (Temporal Logic of Actions) to enable rigorous verification of safety and liveness properties. TLA+ is a formal specification language developed by Leslie Lamport, widely used for verifying distributed systems and protocols.

\textbf{Why TLA+ for Payment Channels}:
\begin{itemize}
    \item \textbf{Temporal Properties}: TLA+ naturally expresses properties like ``eventually closed'' or ``always monotonic''
    \item \textbf{Model Checking}: The TLC model checker can exhaustively verify properties on bounded state spaces
    \item \textbf{Compositionality}: Channel specifications can be composed with network-level specifications
\end{itemize}

\begin{lstlisting}[language=TLA, caption={TLA+ Specification of Channel Monotonicity}, label={lst:tla_spec}]
---------------- MODULE EltooChannel ----------------
(* This module specifies a single Eltoo payment channel *)

VARIABLES state, seq_num, phase

(* Phase enumeration: the four possible channel states *)
Phases == {"init", "active", "settling", "closed"}

(* TypeInvariant: constrains variable domains *)
TypeInv == /\ phase \in Phases
           /\ seq_num \in Nat
           /\ state \in [balances: Nat -> Nat, ptlcs: SUBSET Nat]

(* UPDATE action: increment state in active phase *)
Update == /\ phase = "active"
          /\ seq_num' > seq_num  (* Critical: Monotonicity enforced here *)
          /\ UNCHANGED phase
          /\ state' \in [balances: Nat -> Nat, ptlcs: SUBSET Nat]

(* SETTLE action: transition from active to settling *)
Settle == /\ phase = "active"
          /\ phase' = "settling"
          /\ UNCHANGED <<seq_num, state>>

(* CHALLENGE action: submit higher state during settling *)
Challenge == /\ phase = "settling"
             /\ seq_num' > seq_num  (* Higher state wins *)
             /\ UNCHANGED phase

(* FINALIZE action: close channel after timeout *)
Finalize == /\ phase = "settling"
            /\ phase' = "closed"
            /\ UNCHANGED <<seq_num, state>>

(* Next-state relation: disjunction of all actions *)
Next == Update \/ Settle \/ Challenge \/ Finalize

(* Safety: sequence number never decreases *)
Monotonicity == [][seq_num' >= seq_num]_seq_num

(* Liveness: channel eventually closes *)
EventualTermination == <>(phase = "closed")

(* Specification: initial state + temporal behavior *)
Spec == Init /\ [][Next]_<<state, seq_num, phase>>
=====================================================
\end{lstlisting}

\textbf{Key TLA+ Constructs Explained}:
\begin{itemize}
    \item \texttt{[][A]\_v}: ``Always, if action $A$ occurs, then...''. The subscript $v$ specifies stuttering equivalence.
    \item \texttt{<>(P)}: ``Eventually $P$ holds''. Used for liveness properties.
    \item \texttt{UNCHANGED v}: Variable $v$ retains its value in this transition.
    \item \texttt{seq\_num' > seq\_num}: Primed variables denote next-state values.
\end{itemize}

\textbf{Verification Results}: Model checking with TLC confirms:
\begin{enumerate}
    \item \texttt{Monotonicity} holds for all reachable states (no counterexample found)
    \item \texttt{EventualTermination} holds under fairness assumptions (weak fairness on Finalize)
    \item \texttt{TypeInv} is inductive (preserved by all transitions)
\end{enumerate}

\subsection{Cost and Parameter Analysis}

This section provides a quantitative analysis of the economic and temporal costs associated with the dual-track state machine architecture, demonstrating its efficiency advantages over traditional designs.

\subsubsection{Cost Model}

Total user cost for operating a channel over $N$ state updates is:
$$ C_{\mathrm{total}} = C_{\mathrm{open}} + N \cdot C_{\mathrm{update}} + C_{\mathrm{settle}} $$

\textbf{Component Breakdown}:
\begin{itemize}
    \item $C_{\mathrm{open}}$: One-time on-chain cost to create the channel (FUND transaction). Includes:
    \begin{itemize}
        \item Transaction fee (proportional to tx size)
        \item Opportunity cost of locked capital
    \end{itemize}
    
    \item $C_{\mathrm{update}}$: Per-update cost. In the dual-track architecture:
    $$C_{\mathrm{update}} \approx 0$$
    Updates occur entirely off-chain via cryptographic signature exchange. No on-chain footprint.
    
    \item $C_{\mathrm{settle}}$: One-time on-chain cost to close the channel (SETTLE transaction).
\end{itemize}

\textbf{Amortization Property}:
Since $C_{\mathrm{update}} \approx 0$, the per-transaction amortized cost approaches zero as $N$ grows:
$$\lim_{N \to \infty} \frac{C_{\mathrm{total}}}{N} = \lim_{N \to \infty} \frac{C_{\mathrm{open}} + C_{\mathrm{settle}}}{N} = 0$$

This is the fundamental scaling property of payment channels: fixed setup cost amortized over unlimited transactions.

\subsubsection{GhostDAG Confirmation Parameters}

The GhostDAG consensus provides significantly faster confirmation than traditional blockchains. Confirmation time depends on the DAG width parameter $k$:
$$ T_{\mathrm{confirm}} \approx \frac{D}{k} \cdot \ln(1/\epsilon) $$

\textbf{Parameter Definitions}:
\begin{itemize}
    \item $D$: Network propagation delay (typically 1-2 seconds for global networks)
    \item $k$: GhostDAG width parameter (number of parallel blocks tolerated)
    \item $\epsilon$: Target security level (probability of successful attack)
    \item $T_{\mathrm{confirm}}$: Time until transaction achieves $\epsilon$-security
\end{itemize}

\textbf{Numerical Example}:
For $k=16$ (Kaspa's production parameter) and $\epsilon = 10^{-6}$ (one-in-a-million attack probability):
$$T_{\mathrm{confirm}} \approx \frac{2}{16} \cdot \ln(10^6) \approx 0.125 \cdot 13.8 \approx 1.7 \text{ seconds}$$

With conservative margins, we achieve $10^{-6}$ security in approximately 3 seconds.

\subsubsection{Ref-UTXO Security Depth}

The Ref-UTXO mechanism requires the referenced Fund UTXO to have sufficient confirmation depth to resist reorganization attacks.

We recommend a reference depth of \textbf{10 DAA Score} ($\approx 3$ seconds) to prevent reorganization attacks on the static anchor.

\textbf{Security Analysis}:
\begin{itemize}
    \item \textbf{Attack Scenario}: Adversary creates a channel, performs UPDATE, then attempts to reorganize the chain to ``undo'' the Fund UTXO creation
    \item \textbf{Defense}: By requiring 10 DAA confirmations before accepting Ref operations, any such reorganization becomes computationally infeasible
    \item \textbf{Trade-off}: Deeper requirements increase security but add latency to first UPDATE after FUND
\end{itemize}

\textbf{Comparison with Bitcoin}:
Bitcoin requires 6 confirmations ($\sim$60 minutes) for comparable security. GhostDAG achieves equivalent security in $\sim$3 seconds---a $1200\times$ improvement in confirmation latency.

\begin{table}[htbp]
\centering
\caption{Security Confirmation Time}
\label{tab:confirm_time}
\small
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{System} & \textbf{Time to Finality} \\
\midrule
Bitcoin (6 blocks) & $\sim 60$ minutes \\
\textbf{Native Eltoo (10 DAA)} & $\mathbf{\sim 3}$ \textbf{seconds} \\
\bottomrule
\end{tabular}
\end{table}
